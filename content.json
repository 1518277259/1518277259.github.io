{"meta":{"title":"ysp博客","subtitle":"风雨同路人","description":"对自己学习和生活的记录","author":"杨书平","url":"https://1518277259.github.io","root":"/"},"pages":[{"title":"about","date":"2022-03-29T08:03:29.000Z","updated":"2022-03-29T08:03:29.379Z","comments":true,"path":"about/index.html","permalink":"https://1518277259.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue脚手架创建","slug":"Vue脚手架创建","date":"2022-03-31T07:09:43.000Z","updated":"2022-03-31T07:10:50.857Z","comments":true,"path":"2022/03/31/Vue脚手架创建/","link":"","permalink":"https://1518277259.github.io/2022/03/31/Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA/","excerpt":"","text":"Vue是什么Vue是一套用于构建用户界面的渐进式Javascript框架 Vue的特点 采用组件化模式，提高代码复用率，让代码更好维护 采用声明式编码，让开发人员无需操作DOM，提高开发效率 使用虚拟DOM和diff算法，尽量复用DOM节点 Vue脚手架网速原因先配置淘宝镜像 1npm config set registry https://registry.npm.taobao.org 全局安装@vue&#x2F;cli 1npm install -g @vue/cli 切换到你要创建的目录，使用命令行创建项目XXX 1vue create XXX 启动项目 123npm installnpm run dev/serve 使用命令查看项目的webpack打包配置 1vue inspect &gt; output.js Vue3 使用Vite创建1234567891011// 创建工程npm init vite-app &lt;project-name&gt;// 进入工程目录cd &lt;project-name&gt;// 安装依赖npm install// 运行npm run dev","categories":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/tags/vue/"}]},{"title":"元素居中","slug":"元素居中","date":"2022-03-29T11:05:26.000Z","updated":"2022-03-29T11:13:04.002Z","comments":true,"path":"2022/03/29/元素居中/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/","excerpt":"","text":"水平居中1.行内元素水平居中利用 text-align: center 可以实现在块级元素内部的行内元素水平居中。 此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。 12345.parent&#123; //在父容器设置 text-align:center; &#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent&#123; text-align:center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 2.块级元素的水平居中①、 将该块级元素左右外边距margin-left和margin-right设置为auto 1234.child&#123; width: 100px;//确保该块级元素定宽 margin:0 auto;&#125; ②、使用table+margin 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; ③、使用absolute+transform 12345678910111213&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position:absolute; left:50%; transform:translateX(-50%); &#125; .parent &#123; position:relative; &#125;&lt;/style&gt; ④、使用flex+justify-content 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content:center; &#125;&lt;/style&gt; ⑤、使用flex+margin 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 3、多块级元素水平居中①、利用flex布局 1234#container &#123; display: flex; justify-content: center;&#125; ②、利用inline-block 123456.container &#123;text-align: center;&#125;.inline-block &#123;display: inline-block;&#125; 4、浮动元素水平居中①、定宽的非浮动元素 12345678.child &#123; position:relative; left:50%; margin-left:-250px;&#125;&lt;div class=&quot;parent&quot;&gt; &lt;span class=&quot;child&quot; style=&quot;float: left;width: 500px;&quot;&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; ②、不定宽的浮动元素 1234567891011121314&lt;div class=&quot;box&quot;&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%;&#125;p&#123; float:left; position:relative; right:50%;&#125; ③、通用办法flex布局(不管是定宽还是不定宽) 123456789101112.parent &#123; display:flex; justify-content:center;&#125;.chlid&#123; float: left; width: 200px;//有无宽度不影响居中&#125;&lt;div class=&quot;parent&quot;&gt; &lt;span class=&quot;chlid&quot;&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 5、绝对定位元素水平居中123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt; .parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width: 200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 垂直居中1.单行内联元素垂直居中1234567891011&lt;div id=&quot;box&quot;&gt; &lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 2.多行内联元素垂直居中①、利用flex布局（flex） 123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;p&gt;Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is.&lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; ②、利用表布局（table） 1234567891011121314151617&lt;div class=&quot;parent&quot;&gt; &lt;p class=&quot;child&quot;&gt;The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know.&lt;/p&gt;&lt;/div&gt; &lt;style&gt; .parent &#123; display: table; height: 140px; border: 2px dashed #f69c55; &#125; .child &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 3 块级元素垂直居中①、使用absolute+负margin(已知高度宽度) 12345678910111213&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123;position: relative;&#125;.child &#123;position: absolute;top: 50%;height: 100px;margin-top: -50px;&#125; ②、使用absolute+transform 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123;position: relative;&#125;.child &#123;position: absolute;top: 50%;transform: translateY(-50%);&#125; ③、使用flex+align-items 12345678&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center;&#125; ④、使用table-cell+vertical-align 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 水平垂直居中1、绝对定位与负边距实现（已知高度宽度）123456789101112131415161718// css部分 #container &#123; position: relative; &#125; #center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; &#125; // html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id=&#x27;container&#x27;&gt; &lt;div id=&#x27;center&#x27; style=&quot;width: 100px;height: 100px;background-color: #666&quot;&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 2、绝对定位与margin:auto（已知高度宽度）123456789101112#container &#123; position: relative; height:100px;//必须有个高度 &#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 &#125; 3、绝对定位+CSS3(未知元素的高宽)12345678910#container &#123; position: relative; &#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; 4、flex布局1234567#container &#123;//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; &#125; 5、flex&#x2F;grid与margin:auto(最简单写法)12345678#container &#123; height: 100vh;//必须有高度 display: grid; &#125;#center &#123; margin: auto; &#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"实现三栏布局的方法","slug":"实现三栏布局的方法","date":"2022-03-29T08:53:29.000Z","updated":"2022-03-29T08:54:34.102Z","comments":true,"path":"2022/03/29/实现三栏布局的方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"浮动布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style media=&quot;screen&quot;&gt; html * &#123; padding: 0; margin: 0; &#125; .layout article div &#123; min-height: 150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--浮动布局 --&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;style media=&quot;screen&quot;&gt; .layout.float .left &#123; float: left; width: 300px; background: red; &#125; .layout.float .center &#123; background: yellow; &#125; .layout.float .right &#123; float: right; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; // 右栏部分要写在中间内容之前 &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等。 绝对布局123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right&gt;div&#123; position: absolute;//三块都是绝对定位 &#125; .left &#123; left:0; width: 300px; background: red; &#125; .center &#123; right: 300px; left: 300px;//离左右各三百 background: yellow; &#125; .right &#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; 绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。 flex布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: flex; &#125; .left &#123; width: 300px; background: red; &#125; .center &#123; background: yellow; flex: 1; &#125; .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; lexbox布局是css3里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用flexbox。 flexbox的缺点就是IE10开始支持，但是IE10的是-ms形式的。 表格布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: table; height: 150px; width: 100%; &#125; .left-center-right&gt;div &#123; display: table-cell; &#125; .left &#123; width: 300px; background: red; &#125; .center &#123; background: yellow; &#125; .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; 表格布局的兼容性很好(见下图)，在flex布局不兼容的时候，可以尝试表格布局。当内容溢出时会自动撑开父元素。 表格布局也是有缺陷:①无法设置栏边距；②对seo不友好；③当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。 网格布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: grid; width: 100%; grid-template-columns: 300px auto 300px; grid-template-rows: 150px; //行高 &#125; .left &#123; background: red; &#125; .center &#123; background: yellow; &#125; .right &#123; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; CSS Grid是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让Web设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"Flex布局","slug":"Flex布局","date":"2022-03-29T06:37:18.000Z","updated":"2022-03-29T06:41:36.594Z","comments":true,"path":"2022/03/29/Flex布局/","link":"","permalink":"https://1518277259.github.io/2022/03/29/Flex%E5%B8%83%E5%B1%80/","excerpt":"","text":"Flex 基本概念在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴 Flex 容器实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。如果你使用块元素如 div，你就可以使用 flex，而如果你使用行内元素，你可以使用 inline-flex。 需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 Flex属性1. flex-direction决定主轴的方向(即项目的排列方向) 1234567.container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; row，主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端column：主轴为垂直方向，起点在上沿column-reverse：主轴为垂直方向，起点在下沿 2. flex-wrap:决定容器内项目是否可换行 1234567891011.container &#123; flex-wrap: nowrap | wrap | wrap-reverse; &#125; 默认值：nowrap 不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。wrap：项目主轴总尺寸超出容器时换行，第一行在上方；wrap-reverse：换行，第一行在下方 3. flex-flow:flex-direction 和 flex-wrap 的简写形式 123456.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 默认值为: row nowrap，感觉没什么卵用，老老实实分开写就好了。这样就不用记住这个属性了。 4. justify-content：定义了项目在主轴的对齐方式。 12345678910111213.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 默认值: flex-start 左对齐flex-end：右对齐center：居中space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 5. align-items:定义了项目在交叉轴上的对齐方式 1234567891011.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐flex-end：交叉轴的终点对齐center：交叉轴的中点对齐baseline: 项目的第一行文字的基线对齐 6. align-content:定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用 12345678910111213.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：轴线全部在交叉轴上的起点对齐flex-end：轴线全部在交叉轴上的终点对齐center：轴线全部在交叉轴上的中间对齐space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"CSS高度塌陷","slug":"CSS高度塌陷","date":"2022-03-29T06:13:43.000Z","updated":"2022-03-29T11:14:13.490Z","comments":true,"path":"2022/03/29/CSS高度塌陷/","link":"","permalink":"https://1518277259.github.io/2022/03/29/CSS%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7/","excerpt":"","text":"1.什么是高度塌陷当父元素不设置高度的时候，靠子元素撑大；当子元素浮动后，父元素的高度就会塌陷；父元素下面的元素就会向上移动，导致整个页面混乱。 1234&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; 12345678910111213.box1 &#123; border: 10px red solid; &#125;.box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125;.box3 &#123; height: 100px; background-color: green; &#125; 2.解决方法方法一：给父元素设置高度，固定高度后父元素的高度无法适应子元素的高度。弊端： 不能让元素自适应 12345.box1 &#123; border: 10px red solid; height:100px; &#125; 方法二：给父元素设置overflow：hidden，解决高度塌陷并实现自适应，弊端： 只要里面的内容或元素超出父元素以外就会被隐藏。 1234.box1 &#123; border: 10px red solid; overflow: hidden; &#125; 方法三：在浮动元素下面添加一个空白元素，并给它设置一哈属性；弊端： 会添加很多空标记，增加结构负担，产生代码冗余 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; .clear_fix&#123; /*空白div的属性*/ clear:both; /*清除两侧浮动*/ height:0; overflow:hidden; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clear_fix&quot;&gt;&lt;/div&gt; /*添加空白div*/ &lt;/div&gt; &lt;/body&gt; 方法四：给父元素添加display:table；让父元素转换元素类型和表格一样弊端： 会改变当前元素的元素类型 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; display: table; /* 改变元素类型为表格 */ &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 方法五：万能清除法通过after伪类元素添加一个空白的块元素，css添加下列属性，并给要清除的div加上clear_fix的类名，无副作用。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; .clear_fix:after &#123; /* 要加的属性 */ content: &quot;&quot;; /* 添加内容 */ clear: both; /* 清楚两侧浮动 */ display: block; /* 转换元素类型为块元素 */ height: 0; overflow: hidden; /* 溢出隐藏属性 */ visibility: hidden;/* 隐藏属性 */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1 clear_fix&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"搭建博客网站","slug":"搭建博客网站","date":"2022-03-29T06:09:54.000Z","updated":"2022-03-29T11:17:06.781Z","comments":true,"path":"2022/03/29/搭建博客网站/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","excerpt":"","text":"基础配置1234567npm i -g hexohexo initnpm i hexo-serverhexo-server 主题1.获取模板 1hexo.theme.getView(path); 设置模板 1hexo.theme.setView(path, data); 3.移除模板 1hexo.theme.removeView(path); 配置完成打包上传123hexo clean //删除上次打包hexo generate //打包hexo deploy /上传","categories":[{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/tags/hexo/"}]},{"title":"字符串常用操作方法","slug":"字符串常用操作方法","date":"2022-03-29T06:05:28.000Z","updated":"2022-03-29T11:14:05.200Z","comments":true,"path":"2022/03/29/字符串常用操作方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/","excerpt":"","text":"一. length JS中的字符串有一个length属性，该属性可以用来获取字符串的长度 12const str = &quot;hello&quot;str.length //输出结果5 二.获取字符串指定位置的值 charAt() 方法获取到的是指定位置的字符 charCodeAt()方法获取的是指定位置字符的Unicode值 charAt() 12345const str = &quot;hello&quot;str.chatAt(1) // 输出结果：estr[1] // 输出结果：estr.charAt(5) // 输出结果：&quot;&quot;str[5] // 输出结果：undefine charCodeAt() 12let str = &quot;abcdefg&quot;console.log(str.charCodeAt(1)) // &quot;b&quot;--&gt; 98 三.检索字符串是否包含特定序列 indexOf() 查找某个字符，有则返回第一次匹配到的位置，否则返回-1 123456789string.indexOf(searchvalue,fromindex)searchvalue:必需，规定需检索的字符串值fromindex：可选的整数参数，规定在字符串开始检索的位置。合法取值范围是0-string.length-1.如省略，则从字符串的首字符开始检索let str = &quot;abcdefgabc&quot;console.log(str.indexOf(&quot;a&quot;)) // 输出结果：0console.log(str.indexOf(&quot;z&quot;)) // 输出结果：-1console.log(str.indexOf(&quot;c&quot;,4)) //输出结果：9 lastIndexOf() 查找某个字符，有则返回最后一次匹配的位置，否则返回-1 123let str = “abcabc”console.log(str.lastIndexOf(&quot;a&quot;)) // 输出结果：3console.log(str.lastIndexOf(&quot;z&quot;)) // 输出结果：-1 includes() 该方法用于判断字符串是否包含指定的子字符串，如果找到指定的子字符串，返回true，否则返回false 123456789string.includes(searchvalue,start)searchvalue:必需，要查找的字符串start:可选，设置从那个位置开始查找，默认为0let str = &quot;Hello world&quot;str.includes(&quot;o&quot;) // 输出结果:truestr.includes(&quot;z&quot;) // 输出结果：falsestr.includes(&quot;e&quot;,2) // 输出结果：false startsWith() 该方法用于检测字符串是否以指定的子字符串开始。如果是以指定的子字符串开头返回 true，否则 false。 123456let str = &#x27;Hello world!&#x27;;str.startsWith(&#x27;Hello&#x27;) // 输出结果：truestr.startsWith(&#x27;Helle&#x27;) // 输出结果：falsestr.startsWith(&#x27;wo&#x27;, 6) // 输出结果：true endsWith() 该方法用来判断当前字符串是否是以指定的子字符串结尾。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。 12345678910string.endsWith(searchvalue, length)searchvalue：必需，要搜索的子字符串；length： 设置字符串的长度，默认值为原始字符串长度 string.length。let str = &#x27;Hello world!&#x27;;str.endsWith(&#x27;!&#x27;) // 输出结果：truestr.endsWith(&#x27;llo&#x27;) // 输出结果：falsestr.endsWith(&#x27;llo&#x27;, 5) // 输出结果：true 四、连接多个字符串concat()123456string.concat(string1, string2, ..., stringX)let str = &quot;abc&quot;;console.log(str.concat(&quot;efg&quot;)); //输出结果：&quot;abcefg&quot;console.log(str.concat(&quot;efg&quot;,&quot;hijk&quot;)); //输出结果：&quot;abcefghijk&quot; 五、字符串分割成数组split()用于把一个字符串分割成字符串数组，该方法不会改变原始字符串 12345678string.split(separator,limit)separator:必需。字符串或正则表达式，从该参数指定的位置分割stringlimit：可选，该参数可指定返回的数组的最大长度，如果设置了该参数，返回的子字符串不会多于这个参数指定的数组；如果没有设置该参数，整个字符串都会被分割，不考虑他的长度let str = &quot;abcdef&quot;;str.split(&quot;c&quot;); // 输出结果：[&quot;ab&quot;, &quot;def&quot;]str.split(&quot;&quot;, 4) // 输出结果：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 六、截取字符串 slice() 用于提取字符串的某一部分，并以新的字符串返回提取的部分,该方法返回的子串包括开始处的字符，但不包括结束处的字符。 1234567891011string.slice(start,end)start:必需，要截取的片段的起始下标，第一个字符串位置为0，如果为负数，则从尾部开始截取end: 可选，要截取的片段结尾的下标，若未指定此参数，则要提取的字串包含start到原字符串结尾的字符串。如果是负数，则从字符串的尾部开始算起的位置let str= &quot;abcdefg&quot;str.slice(1,6) // 输出结果：“bcdef”str.slice(1) // 输出结果：“bcdefg”str.slice() // 输出结果：“abcdefg”str.slice(-2) //输出结果：“fg”str.slice(6,1) //输出结果：&quot;&quot; 2.substr()用于在字符串中抽取从开始下标开始的指定数目的字符。 123456789string.substr(start,length)start:必需，要抽取的字串的起始下标。必须是数值。如果是负数，则该参数声明从字符串的尾部开始算起的位置length：可选，子串中字符数。如果省略了该参数，则返回从stringObject的开始位置到结尾的字串let str = &quot;abcdefg&quot;str.substr(1,6) //输出结果：“bcdefg”str.substr(1) // 输出结果：“bcdefg”str.substr(-1) //输出结果：“g” 3.substring()用于提取字符串中介于两个指定下标之间的字符 123456789101112string.substring(from,to)from:必需，一个非负的整数，规定要提取的子串的第一个字符在string的位置to：可选，一个非负的整数，比要提取的子串的最后一个字符在string中的位置多1。如省略，返回的子串会一直到字符串的结尾let str = &quot;abcdefg&quot;str.substring(1,6) //输出结果：“bcdef”str.substring(1) //输出结果：“bcdefg”str.substring() // 输出结果：“abcdefg”str.substring(6,1) // 输出结果：“bcdef”str.substring(-1) // 输出结果：&quot;abcdefg&quot; 七、字符串大小写转换 toLowerCase()用于把字符串转换成小写 12let str = &quot;adABDndj&quot;str.toLowerCase(); //输出结果：“adabdndj” 2.toUpperCase()用于将字符串转换成大写 12let str = “asdfGH”str.toUpperCase(); //输出结果：“ASDFGH” 八、字符串模式匹配1.replace()用于在字符串中用一些字符串替换名一些字符串，或者替换一个与正则表达式匹配的子串 1234567891011string.replace(searchvalue,newvalue)searchvalue:必需，规定子字符串或要替换的模式的RwgExp对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换成RegExp对象newvalue：必需，一个字符串的值let str = “abcdef”str.replace(&quot;c&quot;,&quot;a&quot;) // 输出结果：abadeflet str=&quot;Mr Blue has a blue house and a blue car&quot;;str.replace(/blue/gi, &quot;red&quot;); // 输出结果：&#x27;Mr red has a red house and a red car&#x27; match() 用于在字符串内检索特定的值，或找到一个或多个正则表达式的匹配 1234string.match(regexp)let str = &quot;abcdef&quot;console.log(str.match(&quot;c&quot;)) // // [&quot;c&quot;, index: 2, input: &quot;abcdef&quot;, groups: undefined] search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。只会返回第一次匹配成功的结果;如果没有找到任何匹配的子串，则返回 -1。 12345string.search(searchvalue)let str = &quot;abcdef&quot;;str.search(/bcd/) // 输出结果：1 九、移除字符串首尾空白符 trim() 用于移除字符串首尾空白符，该方法不会改变原始字符串 123let str = &quot; abcdef &quot;str.trim() // 输出结果：&quot;abcdef&quot; trimStart() trimStart() 方法的的行为与trim()一致，不过会返回一个从原始字符串的开头删除了空白的新字符串，不会修改原始字符串： 123const s = &#x27; abc &#x27;;s.trimStart() // &quot;abc &quot; trimEnd() trimEnd() 方法的的行为与trim()一致，不过会返回一个从原始字符串的结尾删除了空白的新字符串，不会修改原始字符串： 1234const s = &#x27; abc &#x27;;s.trimEnd() // &quot; abc&quot; 十、获取字符串本身 valueOf() 返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。 12let str = &quot;abcdef&quot;console.log(str.valueOf()) // &quot;abcdef&quot; toString() 返回字符串对象本身 12let str = &quot;abcdef&quot;console.log(str.toString()) // &quot;abcdef&quot; 十一、重复一个字符串repeat()返回一个新字符串，表示将原字符串重复n次： 123&#x27;x&#x27;.repeat(3) // 输出结果：&quot;xxx&quot;&#x27;hello&#x27;.repeat(2) // 输出结果：&quot;hellohello&quot;&#x27;na&#x27;.repeat(0) // 输出结果：&quot;&quot; 注意：如果参数是小数，向下取整；如果参数是负数或Infinity，会报错 十二、补齐字符串长度 padStart() 用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 1234567&#x27;x&#x27;.padStart(1, &#x27;ab&#x27;) // &#x27;x&#x27;&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;) // &#x27;ababx&#x27;&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;) // &#x27;abax&#x27;&#x27;x&#x27;.padStart(4) // &#x27; x&#x27;&quot;1&quot;.padStart(3, &#x27;0&#x27;) // 输出结果： &#x27;001&#x27;&quot;15&quot;.padStart(3, &#x27;0&#x27;) // 输出结果： &#x27;015&#x27; padEnd() 用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串： 123&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;) // &#x27;xabab&#x27;&#x27;x&#x27;.padEnd(4, &#x27;ab&#x27;) // &#x27;xaba&#x27; 十三、字符串转为数字1.parseInt() 用于可解析一个字符串，并返回一个整数 12345678910111213141516171819202122parseInt(string, radix)string:必需，要被解析的字符串radix：可选，表示要解析的数字的基数。parseInt(&quot;10&quot;); // 输出结果：10parseInt(&quot;17&quot;,8); // 输出结果：15 (8+7)parseInt(&quot;010&quot;); // 输出结果：10 或 8parseInt(&quot;0x10&quot;) // 输出结果：16parseInt(&quot;50&quot;, 1) // 输出结果：NaNparseInt(&quot;50&quot;, 40) // 输出结果：NaNparseInt(&quot;40 4years&quot;) // 输出结果：40parseInt(&quot;new100&quot;) // 输出结果：NaNparseInt(&quot; 60 &quot;) // 输出结果： 60 parseFloat(string) 可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 123456parseFloat(&quot;10.00&quot;) // 输出结果：10.00parseFloat(&quot;10.01&quot;) // 输出结果：10.01parseFloat(&quot;-10.01&quot;) // 输出结果：-10.01parseFloat(&quot;40.5 years&quot;) // 输出结果：40.5","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"数组Array的常用方法","slug":"数组Array的常用方法","date":"2022-03-29T03:36:26.000Z","updated":"2022-03-29T11:13:50.725Z","comments":true,"path":"2022/03/29/数组Array的常用方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E6%95%B0%E7%BB%84Array%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Array.map()将数组中的每一个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组 12345let arr = [1, 2, 3, 4, 5];let newArr = arr.map(x =&gt; x*2);// arr = [1, 2, 3, 4, 5] 原数组保持不变// newArr = [2, 4, 6, 8, 10] 返回新数组 Array.forEach()将数组中的每个元素执行传进提供的函数，没有返回值 12345let arr = [1, 2, 3, 4, 5];arr.forEach(x =&gt; x*2);console.log(arr)// arr = [1, 2, 3, 4, 5] 数组改变,注意和map区分 Array.filter()将所有元素进行判断，将满足条件的元素作为一个新的数组返回 1234let arr = [1, 2, 3, 4, 5];const isBigEnough = value =&gt; value &gt;= 3;let newArr = arr.filter(isBigEnough);// newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组 Array.eveny()将所有的元素进行判断返回一个布尔值，如果所有元素都满足条件，返回true，否则返回false 123456let arr = [1, 2, 3, 4, 5];const isLessThan4 = value =&gt; value &lt; 4;const isLessThan6 = value =&gt; value &lt; 6;arr.every(isLessThan4); // falsearr.every(isLessThan6); // true Array.some()此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false。 123456let arr= [1, 2, 3, 4, 5];const isLessThan4 = value =&gt; value &lt; 4;const isLessThan6 = value =&gt; value &gt; 6;arr.some(isLessThan4); // truearr.some(isLessThan6); // false Array.reduce()所有元素调用返回函数，返回值为最终结果，传入的值必需是函数类型 1234567let arr = [1, 2, 3, 4, 5];const add = (a, b) =&gt; a + b;let sum = arr.reduce(add);// sum = 15 相当于累加的效果// 与之相对应的还有一个 Array.reduceRight() 方法，// 区别是这个是从右向左操作的 Array.push()在数组的后面添加元素，改变了数组的长度 123456var str1 = [12,2,&quot;hello&quot;];var str2 = [43,2,&quot;test&quot;];console.log(str1.push(&quot;你好&quot;)); // 4console.log(str2.push(&quot;hello&quot;,&quot;world&quot;)); // 5console.log(str1); // [12, 2, &quot;hello&quot;,&quot;你好&quot;]console.log(str2); // [43, 2, &quot;test&quot;,&quot;hello&quot;, &quot;world&quot;] Array.pop()在数组后面删除最后一位元素，并返回数组，改变了数组的长度 12345let arr = [1, 2, 3, 4, 5];arr.pop();console.log(arr); // [1, 2, 3, 4]console.log(arr.length); // 4 Array.shift()删除数组的第一个元素，并返回数组，改变数组的长度 12345let arr = [1, 2, 3, 4, 5];arr.shift();console.log(arr); // [2, 3, 4, 5]console.log(arr.length); // 4 Array.unshift()将一个或多个元素添加到数组的开头，并返回数组的长度 1234567var str1 = [12,2,&quot;hello&quot;];var str2 = [43,2,&quot;test&quot;];console.log(str1.unshift(&quot;你好&quot;)); // 4console.log(str2.unshift(&quot;hello&quot;,&quot;world&quot;)); // 5console.log(str1); // [&quot;你好&quot;, 12, 2, &quot;hello&quot;]console.log(str2); // [&quot;hello&quot;, &quot;world&quot;, 43, 2, &quot;test&quot;] Array.isArray()判断一个对象是不是数组，返回是布尔值 123let arr = [1, 2, 3, 4, 5];console.log(arr.isArray()); // true Array.concat()可以将多个数组拼成一个数组 1234let arr1 = [1, 2, 3];arr2 = [4, 5];let arr = arr1.concat(arr2);console.log(arr); // [1, 2, 3, 4, 5] Array.toString()将数组转换成字符串，不会改变原数组 123let arr = [1, 2, 3, 4, 5];let str = arr.toString();console.log(str); // 1,2,3,4,5 Array.join()将数组转成字符串并返回字符串数据，不会改变原来的数组 1234567let arr = [1, 2, 3, 4, 5];let str1 = arr.join();let str2 = arr.join(&#x27;,&#x27;);let str3 = arr.join(&#x27;##&#x27;);console.log(str1); // 12345console.log(str2); // 1,2,3,4,5console.log(str3); // 1##2##3##4##5 Array.splice()Array.splice(开始位置，删除的个数，元素)，万能方法，可以实现增删改 1234567let arr = [1, 2, 3, 4, 5];let arr1 = arr.splice(2, 0 &#x27;haha&#x27;);let arr2 = arr.splice(2, 3);let arr1 = arr.splice(2, 1 &#x27;haha&#x27;);console.log(arr1); // [1, 2, &#x27;haha&#x27;, 3, 4, 5] 新增一个元素console.log(arr2); // [1, 2] 删除三个元素console.log(arr3); // [1, 2, &#x27;haha&#x27;, 4, 5] 替换一个元素 Array.slice()此方法截取指定位置的数组，并返回截取的数组，不会改变原数组。 12345678var arr = [&quot;T1&quot;,&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;];console.log(arr.slice(1,3)); // [&quot;J1&quot;,&quot;L1&quot;]console.log(arr.slice(1)); // [&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;]console.log(arr.slice(-4,-1)); // [&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;]console.log(arr.slice(-2)); // [&quot;L2&quot;,&quot;M1&quot;]console.log(arr.slice(1,-2)); // [&quot;J1&quot;,&quot;L1&quot;]console.log(arr); // [&quot;T1&quot;,&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;] Array.reverse()将数组的数据进行反转，并返回反转后的数组，会改变原数组 123var str1 = [12,2,&quot;hello&quot;];console.log(str1.reverse()); // [&quot;hello&quot;, 2, 12]console.log(str1); // [&quot;hello&quot;, 2, 12] Array.sort()将数组内的数据进行排序，并返回排过序的新数组，会改变原来的数组 1234567var str1 = [12,2,43,5,2,5];var str2 = [92,2,43,&quot;hello&quot;,&#x27;zoom&#x27;,5,2,5];console.log(str1.sort()); // [12, 2, 2, 43, 5, 5]console.log(str1); // [12, 2, 2, 43, 5, 5]console.log(str2.sort()); // [2, 2, 43, 5, 5, 92, &quot;abc&quot;, &quot;hello&quot;, &quot;zoom&quot;]console.log(str2); // [2, 2, 43, 5, 5, 92, &quot;abc&quot;, &quot;hello&quot;, &quot;zoom&quot;] Array.valueOf()返回数组的原始值，一般由js在后台调用，并不显示的出现在代码中 123456var str = [1,2,3];console.log(str.valueOf()); // [1,2,3]console.log(str); // [1,2,3]// 为了证明返回的是数组自身console.log(str.valueOf() == str); // true Array.IndexOf()此方法根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1，找到了指定的数据返回该数据的索引 1234567var str = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;];console.log(str.indexOf(&quot;l&quot;)); // 2console.log(str.indexOf(&quot;l&quot;,3)); // 3console.log(str.indexOf(&quot;l&quot;,4)); // -1console.log(str.indexOf(&quot;l&quot;,-1)); // -1console.log(str.indexOf(&quot;l&quot;,-3)); // 2 Array.includes()用来判断一个数组是否包含一个指定的值，如果是返回true，否则返回false 1234let site = [&#x27;runoob&#x27;, &#x27;google&#x27;, &#x27;taobao&#x27;];console.log(site.includes(&#x27;runoob&#x27;)); // true console.log(site.includes(&#x27;baidu&#x27;)); // false Array.flat()用来实现数据的扁平化 1234let site = [1, 2, [3, 4]];console.log(arr1.flat());// [1, 2, 3, 4]","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/categories/vue/"},{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"},{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/categories/hexo/"},{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/tags/vue/"},{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"},{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/tags/hexo/"},{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}