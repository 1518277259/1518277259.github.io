{"meta":{"title":"ysp博客","subtitle":"风雨同路人","description":"对自己学习和生活的记录","author":"杨书平","url":"https://1518277259.github.io","root":"/"},"pages":[{"title":"about","date":"2022-03-29T08:03:29.000Z","updated":"2022-03-29T08:03:29.379Z","comments":true,"path":"about/index.html","permalink":"https://1518277259.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式","slug":"设计模式","date":"2023-02-19T02:24:51.000Z","updated":"2023-03-02T12:32:17.649Z","comments":true,"path":"2023/02/19/设计模式/","link":"","permalink":"https://1518277259.github.io/2023/02/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式创建型模式原型模式是用于创建重复的对象，同时又能保证性能。 123456789101112function Person () &#123; Person.prototype.name = &quot;marry&quot;; Person.prototype.sayName = function()&#123; console.log(this.name); &#125;&#125; const person1 = new Person();const person2 = new Person();person1.sayName(); // marryperson2.sayName(); // marryconsole.log(person1.sayName === person2.sayName); // true 单例模式单例模式（Singleton Pattern）涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。 特点： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 1234567891011121314151617// 单例模式let box;const createBox = (_a, _b) =&gt; &#123; if(!box)&#123; box = &#123;&#125;; &#125; box.a = _a; box.b = _b; return box;&#125;; const obj1 = createBox(3, 6);obj1; // &#123;a: 3, b: 6&#125; const obj2 = createBox(10, 20);obj1; // &#123;a: 10, b: 20&#125;obj2; // &#123;a: 10, b: 20&#125; 工厂模式根据不同的输入返回不同类的实例，一般用来创建同一类对象 优点： 良好的封装，代码结构清晰，访问者无需知道对象的创建流程，特别是创建比较复杂的情况下； 扩展性优良，通过工厂方法隔离了用户和创建流程隔离，符合开放封闭原则； 解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流； 缺点：&amp;emsp;&amp;emsp;带来了额外的系统复杂度，增加了抽象性； 123456789101112131415161718192021222324252627282930313233343536373839// 饭店方法 class Restaurant &#123; static getMenu(menu) &#123; switch (menu) &#123; case &#x27;鱼香肉丝&#x27;: return new YuXiangRouSi(); case &#x27;宫保鸡丁&#x27;: return new GongBaoJiDin(); default: throw new Error(&#x27;这个菜本店没有&#x27;); &#125; &#125;&#125;; // 鱼香肉丝类 class YuXiangRouSi &#123; constructor() &#123; this.type = &#x27;鱼香肉丝&#x27; &#125; eat() &#123; console.log(this.type + &#x27; 真香&#x27;) &#125;&#125;; // 宫保鸡丁类class GongBaoJiDin &#123; constructor() &#123; this.type = &#x27;宫保鸡丁&#x27; &#125; eat() &#123; console.log(this.type + &#x27; 让我想起了外婆做的菜&#x27;); &#125;&#125;; const dish1 = Restaurant.getMenu(&#x27;鱼香肉丝&#x27;);dish1.eat(); // 鱼香肉丝 真香const dish2 = Restaurant.getMenu(&#x27;红烧排骨&#x27;); // Error 这个菜本店没有 抽象工厂模式&amp;emsp;&amp;emsp;通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，从实例的具体实现中解耦。 优点：&amp;emsp;&amp;emsp;抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦； 缺点： 扩展新类簇的产品类比较困难，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开放封闭原则； 带来了系统复杂度，增加了新的类，和新的继承关系； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 饭店 抽象类，饭店都可以做菜和汤class AbstractRestaurant &#123; constructor() &#123; if (new.target === AbstractRestaurant) &#123; throw new Error(&#x27;抽象类不能直接实例化!&#x27;) &#125; this.signborad = &#x27;饭店&#x27; &#125; // 抽象方法：创建菜 createDish() &#123; throw new Error(&#x27;抽象方法不能调用!&#x27;) &#125; // 抽象方法：创建汤 createSoup() &#123; throw new Error(&#x27;抽象方法不能调用!&#x27;) &#125;&#125; // 饭店 具体类 class Restaurant extends AbstractRestaurant &#123; constructor() &#123; super() &#125; createDish(type) &#123; switch (type) &#123; case &#x27;鱼香肉丝&#x27;: return new YuXiangRouSi(); case &#x27;宫保鸡丁&#x27;: return new GongBaoJiDing(); default: throw new Error(&#x27;本店没这个菜&#x27;); &#125; &#125; createSoup(type) &#123; switch (type) &#123; case &#x27;紫菜蛋汤&#x27;: return new ZiCaiDanTang(); default: throw new Error(&#x27;本店没这个汤&#x27;); &#125; &#125;&#125; // 菜 抽象类，菜都有吃的功能class AbstractDish &#123; constructor() &#123; if (new.target === AbstractDish) &#123; throw new Error(&#x27;抽象类不能直接实例化!&#x27;) &#125; this.kind = &#x27;菜&#x27; &#125; // 抽象方法 eat() &#123; throw new Error(&#x27;抽象方法不能调用!&#x27;) &#125;&#125; // 菜 鱼香肉丝类class YuXiangRouSi extends AbstractDish &#123; constructor() &#123; super() this.type = &#x27;鱼香肉丝&#x27; &#125; eat() &#123; console.log(this.kind + &#x27; - &#x27; + this.type + &#x27; 真香~&#x27;) &#125;&#125;// 菜 宫保鸡丁类class GongBaoJiDing extends AbstractDish &#123; constructor() &#123; super() this.type = &#x27;宫保鸡丁&#x27; &#125; eat() &#123; console.log(this.kind + &#x27; - &#x27; + this.type + &#x27; 让我想起了外婆做的菜&#x27;) &#125;&#125; // 汤 抽象类，汤都有喝的功能class AbstractSoup &#123; constructor() &#123; if (new.target === AbstractDish) &#123; throw new Error(&#x27;抽象类不能直接实例化!&#x27;) &#125; this.kind = &#x27;汤&#x27; &#125; // 抽象方法 drink() &#123; throw new Error(&#x27;抽象方法不能调用!&#x27;) &#125;&#125; // 汤 紫菜蛋汤类class ZiCaiDanTang extends AbstractSoup &#123; constructor() &#123; super() this.type = &#x27;紫菜蛋汤&#x27; &#125; drink() &#123; console.log(this.kind + &#x27; - &#x27; + this.type + &#x27; 我从小喝到大&#x27;) &#125;&#125; const restaurant = new Restaurant(); const soup1 = restaurant.createSoup(&#x27;紫菜蛋汤&#x27;);soup1.drink();// 汤 - 紫菜蛋汤 我从小喝到大const dish1 = restaurant.createDish(&#x27;鱼香肉丝&#x27;);dish1.eat();// 菜 - 鱼香肉丝 真香const dish2 = restaurant.createDish(&#x27;红烧排骨&#x27;);// Error 本店没有这个 建造者模式用于分步构建一个复杂的对象，将一个复杂对象的 构建层与其表示层分离。若不是极其复杂的对象，应选择使用对象字面或工厂模式等方式创建对象。 优点： 封装性好，创建和使用分离； 扩展性好，建造类之间独立、一定程度上解耦。 缺点: 产生多余的Builder对象； 产品内部发生变化，建造者都要修改，成本较大。 12345678910111213141516171819202122232425262728293031// 建造者，汽车部件厂家class CarBuilder &#123; constructor(param) &#123; this.param = param; &#125; // 生产部件，part1 buildPart1() &#123; this.part1 = &#x27;part1&#x27;; return this &#125; // 生产部件，part2 buildPart2() &#123; this.part2 = &#x27;part2&#x27;; return this; &#125;&#125; // 汽车装配，获得产品实例const benchi1 = new CarBuilder(&#x27;param&#x27;).buildPart1().buildPart2(); console.log(benchi1); // &#123;// param: &quot;param&quot;// part1: &quot;part1&quot;// part2: &quot;part2&quot;// &#125; 结构性模式桥架模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。 优点： 分离了抽象和实现部分，将实现层（DOM 元素事件触发并执行具体修改逻辑）和抽象层（ 元素外观、尺寸部分的修改函数）解耦，有利于分层； 提高了可扩展性，多个维度的部件自由组合，避免了类继承带来的强耦合关系，也减少了部件类的数量； 使用者不用关心细节的实现，可以方便快捷地进行使用； 缺点： 桥接模式要求两个部件没有耦合关系，否则无法独立地变化，因此要求正确的对系统变化的维度进行识别，使用范围存在局限性； 桥接模式的引入增加了系统复杂度； 12345678910111213141516171819202122232425262728293031323334353637383940function Boy(instrument) &#123; this.sayHi = function() &#123; console.log(&#x27;hi, 我是男生&#x27;) &#125; // 有一个功能叫playInstrument， 没有具体乐器 this.playInstrument = function() &#123; instrument.play() &#125;&#125; function Girl(instrument) &#123; this.sayHi = function() &#123; console.log(&#x27;hi, 我是女生&#x27;) &#125; // 有一个功能叫playInstrument， 没有具体乐器 this.playInstrument = function() &#123; instrument.play() &#125;&#125; function Piano() &#123; this.play = function() &#123; console.log(&#x27;钢琴开始演奏&#x27;) &#125;&#125; function Guitar() &#123; this.play = function() &#123; console.log(&#x27;吉他开始演奏&#x27;) &#125;&#125; let piano = new Piano()let guitar = new Guitar()let pianoBoy = new Boy(piano)pianoBoy.playInstrument()let guitarGirl = new Girl(guitar)guitarGirl.playInstrument() 外观模式外观模式为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。 优点： 访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的 使用变得简单 ，符合最少知识原则，增强了可移植性和可读性； 减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性； 通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性； 缺点： 不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口； 不需要或不合理的使用外观会让人迷惑，过犹不及； 1234567891011function setBox()&#123; var getId = document.getElementById(&#x27;isShow&#x27;); return &#123; show : function()&#123; getId.style.display = &#x27;block&#x27;; &#125;, hide : function()&#123; getId.style.display = &#x27;none&#x27;; &#125; &#125;&#125; 享元模式运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。通俗来讲，享元就是共享单元，比如现在流行的共享单车、共享充电宝等，他们的核心理念都是享元模式。 优点： 由于减少了系统中的对象数量，提高了程序运行效率和性能，精简了内存占用，加快运行速度； 外部状态相对独立，不会影响到内部状态，所以享元对象能够在不同的环境被共享； 缺点： 引入了共享对象，使对象结构变得复杂； 共享对象的创建、销毁等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899var Upload = function(uploadType) &#123; this.uploadType = uploadType;&#125;/* 删除文件（内部状态） */Upload.prototype.delFile = function(id) &#123; uploadManger.setExternalState(id, this); // 把当前id对应的外部状态都组装到共享对象中 // 大于3000k提示 if(this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if(window.confirm(&quot;确定要删除文件吗？&quot; + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;/** 工厂对象实例化 * 如果某种内部状态的共享对象已经被创建过，那么直接返回这个对象 * 否则，创建一个新的对象 */var UploadFactory = (function() &#123; var createdFlyWeightObjs = &#123;&#125;; return &#123; create: function(uploadType) &#123; if(createdFlyWeightObjs[uploadType]) &#123; return createdFlyWeightObjs[uploadType]; &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType); &#125; &#125;;&#125;)();/* 管理器封装外部状态 */var uploadManger = (function() &#123; var uploadDatabase = &#123;&#125;;​ return &#123; add: function(id, uploadType, fileName, fileSize) &#123; var flyWeightObj = UploadFactory.create(uploadType); var dom = document.createElement(&#x27;div&#x27;); dom.innerHTML = &quot;&lt;span&gt;文件名称：&quot; + fileName + &quot;，文件大小：&quot; + fileSize +&quot;&lt;/span&gt;&quot; + &quot;&lt;button class=&#x27;delFile&#x27;&gt;删除&lt;/button&gt;&quot;;​ dom.querySelector(&quot;.delFile&quot;).onclick = function() &#123; flyWeightObj.delFile(id); &#125;; document.body.appendChild(dom);​ uploadDatabase[id] = &#123; fileName: fileName, fileSize: fileSize, dom: dom &#125;;​ return flyWeightObj; &#125;, setExternalState: function(id, flyWeightObj) &#123; var uploadData = uploadDatabase[id]; for(var i in uploadData) &#123; // 直接改变形参（新思路！！） flyWeightObj[i] = uploadData[i]; &#125; &#125; &#125;;&#125;)();​/*触发上传动作*/var id = 0;window.startUpload = function(uploadType, files) &#123; for(var i=0,file; file = files[i++];) &#123; var uploadObj = uploadManger.add(++id, uploadType, file.fileName, file.fileSize); &#125;&#125;;​/* 测试 */startUpload(&quot;plugin&quot;, [ &#123; fileName: &#x27;1.txt&#x27;, fileSize: 1000 &#125;,&#123; fileName: &#x27;2.txt&#x27;, fileSize: 3000 &#125;,&#123; fileName: &#x27;3.txt&#x27;, fileSize: 5000 &#125;]);startUpload(&quot;flash&quot;, [ &#123; fileName: &#x27;4.txt&#x27;, fileSize: 1000 &#125;,&#123; fileName: &#x27;5.txt&#x27;, fileSize: 3000 &#125;,&#123; fileName: &#x27;6.txt&#x27;, fileSize: 5000 &#125;]); 适配器模式代理模式组合模式装饰器模式组合模式装饰器模式行为型模式观察者模式迭代器模式策略模式模板方法模式状态模式命令模式访问者模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://1518277259.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://1518277259.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"websocket解析","slug":"websocket解析","date":"2023-02-18T02:24:51.000Z","updated":"2023-03-02T12:29:07.011Z","comments":true,"path":"2023/02/18/websocket解析/","link":"","permalink":"https://1518277259.github.io/2023/02/18/websocket%E8%A7%A3%E6%9E%90/","excerpt":"","text":"websocket解析什么是websocket WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议） 它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的 Websocket是一个持久化的协议 websocket的原理 websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信 在websocket出现之前，web交互一般是基于http协议的短连接或者长连接 websocket是一种全新的协议，不属于http无状态协议，协议名为”ws” websocket与http的关系相同点： 都是基于tcp的，都是可靠性传输协议 都是应用层协议 不同点： WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息 HTTP是单向的 WebSocket是需要浏览器和服务器握手进行建立连接的 http是浏览器发起向服务器的连接，服务器预先并不知道这个连接 联系WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的 总结 首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等； 然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据； 最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。 JS websocket实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import Store from &quot;@/store&quot;;class WebSocketClass &#123; // 要连接的URL url; // 一个协议字符串或一个协议字符串数组。 // 这些字符串用来指定子协议，这样一个服务器就可以实现多个WebSocket子协议 protocols; // WebSocket 实例 ws; // 是否在重连中 isReconnectionLoading = false; // 延时重连的 id timeId = null; // 是否是用户手动关闭连接 isCustomClose = false; // 错误消息队列 errorStack = []; constructor(url, protocols) &#123; this.url = url; this.protocols = protocols; this.createWs(); &#125; createWs() &#123; if (&quot;WebSocket&quot; in window) &#123; // 实例化 this.ws = new WebSocket(this.url, this.protocols); // 监听事件 this.onopen(); this.onerror(); this.onclose(); this.onmessage(); &#125; else &#123; console.log(&quot;你的浏览器不支持 WebSocket&quot;); &#125; &#125; // 监听成功 onopen() &#123; this.ws.onopen = () =&gt; &#123; console.log(&quot;onopen&quot;); // 发送成功连接之前所发送失败的消息 this.errorStack.forEach((message) =&gt; &#123; this.send(message); &#125;); this.errorStack = []; this.isReconnectionLoading = false; &#125;; &#125; // 监听错误 onerror() &#123; this.ws.onerror = (err) =&gt; &#123; console.log(err, &quot;onerror&quot;); this.reconnection(); this.isReconnectionLoading = false; &#125;; &#125; // 监听关闭 onclose() &#123; this.ws.onclose = () =&gt; &#123; console.log(&quot;onclose&quot;); // 用户手动关闭的不重连 if (this.isCustomClose) return; this.reconnection(); this.isReconnectionLoading = false; &#125;; &#125; // 接收 WebSocket 消息 onmessage() &#123; this.ws.onmessage = (event) =&gt; &#123; try &#123; Store.dispatch(&quot;user/setData&quot;, event.data); &#125; catch (error) &#123; console.log(error, &quot;error&quot;); &#125; &#125;; &#125; // 是否连接中 isConnection() &#123; if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) return true else return false &#125; // 重连 reconnection() &#123; // 防止重复 if (this.isReconnectionLoading) return; this.isReconnectionLoading = true; clearTimeout(this.timeId); this.timeId = setTimeout(() =&gt; &#123; this.createWs(); &#125;, 100); &#125; // 发送消息 send(message) &#123; // 连接失败时的处理 if (this.ws.readyState !== 1) &#123; this.errorStack.push(message); return; &#125; this.ws.send(message); &#125; // 手动关闭 close() &#123; this.isCustomClose = true; this.ws.close(); &#125; // 手动开启 start() &#123; this.isCustomClose = false; this.reconnection(); &#125; // 销毁 destroy() &#123; this.close(); this.ws = null; this.errorStack = null; &#125;&#125;export default WebSocketClass;","categories":[{"name":"websocket","slug":"websocket","permalink":"https://1518277259.github.io/categories/websocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://1518277259.github.io/tags/websocket/"}]},{"title":"webpack解析","slug":"webpack解析","date":"2023-02-17T02:24:51.000Z","updated":"2023-03-02T12:15:57.942Z","comments":true,"path":"2023/02/17/webpack解析/","link":"","permalink":"https://1518277259.github.io/2023/02/17/webpack%E8%A7%A3%E6%9E%90/","excerpt":"","text":"webpack解析webpack的理解webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。我们可以使用webpack管理模块。因为在webpack看来，项目中的所有资源皆为模块，通过分析模块间的依赖关系，在其内部构建出一个依赖图，最终编绎输出模块为 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等），让我们的开发过程更加高效。 主要作用 模块打包：可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。 编译兼容：在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less，.vue，.jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。 能力扩展:通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。 webpack的构建流程 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过上一步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 常见的loader image-loader：加载并且压缩图片文件。 less-loader： 加载并编译 LESS 文件。 sass-loader：加载并编译 SASS&#x2F;SCSS 文件。 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性，使用css-loader必须要配合使用style-loader。 style-loader：用于将 CSS 编译完成的样式，挂载到页面的 style 标签上。需要注意 loader 执行顺序，style-loader 要放在第一位，loader 都是从后往前执行。 babel-loader：把 ES6 转换成 ES5 postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀。 eslint-loader：通过 ESLint 检查 JavaScript 代码。 vue-loader：加载并编译 Vue 组件。 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体) url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体) 常见的plugin有哪些？ HtmlWebpackPlugin：简化 HTML 文件创建 (依赖于 html-loader) mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin) clean-webpack-plugin: 目录清理 loader和plugin的区别？&amp;emsp;&amp;emsp;loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中；&amp;emsp;&amp;emsp;plugin赋予了webpack各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader无法实现的其他事。&amp;emsp;&amp;emsp;在运行时机上，loader 运行在打包文件之前；plugin则是在整个编译周期都起作用。&amp;emsp;&amp;emsp;在配置上，loader在module.rules中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性；plugin在 plugins中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。 webpack的热更新原理是？&amp;emsp;&amp;emsp;模块热替换(HMR - hot module replacement)，又叫做热更新，在不需要刷新整个页面的同时更新模块，能够提升开发的效率和体验。热更新时只会局部刷新页面上发生了变化的模块，同时可以保留当前页面的状态，比如复选框的选中状态等。&amp;emsp;&amp;emsp;热更新的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上webpack-dev-server与浏览器之间维护了一个websocket，当本地资源发生变化时，webpack-dev-server会向浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比。客户端对比出差异后会向webpack-dev-server发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向webpack-dev-server发起 jsonp 请求获取该chunk的增量更新。&amp;emsp;&amp;emsp;后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader和vue-loader都是借助这些 API 实现热更新。 如何提高webpack的构建速度？ 代码压缩 JS压缩：&amp;emsp;&amp;emsp;webpack 4.0默认在生产环境的时候是支持代码压缩的，即mode&#x3D;production模式下。实际上webpack 4.0默认是使用terser-webpack-plugin这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel参数，使用多进程压缩，加快压缩。 CSS压缩&amp;emsp;&amp;emsp;CSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件：css-minimizer-webpack-plugin。 HTML压缩&amp;emsp;&amp;emsp;使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。 图片压缩:配置image-webpack-loader Tree Shaking: 缩小打包域:&amp;emsp;&amp;emsp;排除webpack不需要解析的模块，即在使用loader的时候，在尽量少的模块中去使用。可以借助 include和exclude这两个参数，规定loader只在那些模块应用和在哪些模块不应用。","categories":[{"name":"webpack","slug":"webpack","permalink":"https://1518277259.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://1518277259.github.io/tags/webpack/"}]},{"title":"模块化方案","slug":"模块化方案","date":"2023-02-16T01:34:55.000Z","updated":"2023-03-02T12:11:45.094Z","comments":true,"path":"2023/02/16/模块化方案/","link":"","permalink":"https://1518277259.github.io/2023/02/16/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88/","excerpt":"","text":"模块化方案模块化优点 可维护性：每个模块都是单独定义的，之间相互独立 命名空间：为了避免在JavaScript中的全局污染，我们通过模块化的方式利用函数作用域来构建命名空间 可复用 模块化方案揭示模块模式(Reveaing Module)123456789101112131415161718192021var myRevealingModule = (function () &#123; var privateVar = “Ben Cherry”, publicVar = “Hey there!”; function privateFunction() &#123; console.log( &quot;Name:&quot; + privateVar ); &#125; function publicSetName( strName ) &#123; privateVar = strName; &#125; function publicGetName() &#123; privateFunction(); &#125; return &#123; setName: publicSetName, greeting: publicVar, getName: publicGetName &#125;;&#125;)();myRevealingModule.setName( “Paul Kinlan” ); 优点: 可以在任何地方实现（没有库，不需要语言支持）。 可以在单个文件中定义多个模块。 缺点: 无法以编程方式导入模块（除非使用eval）。 需要手动处理依赖关系。 无法异步加载模块。4。 循环依赖可能很麻烦。 很难通过静态代码分析器进行分析。 CommonJSCommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作(require 和 exports) 优点: 简单：开发人员可以在不查看文档的情况下掌握概念。 集成了依赖管理：模块需要其他模块并按所需顺序加载。 require可以在任何地方调用：模块可以通过编程方式加载。 缺点: 同步API使其不适合某些用途（客户端）。 每个模块一个文件。 浏览器需要加载程序库或转换。 模块没有构造函数（Node支持）。 很难进行静态代码分析。 ##### AMD AMD规范则是异步加载模块，允许指定回调函数，通过返回一个对象做为模块对象 优点: 异步加载（更好的启动时间）。 支持循环依赖。 require和的兼容性exports。 完全整合了依赖管理。 如有必要，可以将模块拆分为多个文件。 支持构造函数。 插件支持（自定义加载步骤）。 缺点: 语法稍微复杂一些。 除非编译，否则需要加载程序库。 很难分析静态代码。 除了异步加载以外，AMD的另一个优点是你可以在模块里使用对象、函数、构造函数、字符串、JSON或者别的数据类型，而CommonJS只支持对象。UMD 统一模块定义（UMD：Universal Module Definition ）就是将 AMD 和 CommonJS合在一起的一种尝试，常见的做法是将CommonJS 语法包裹在兼容 AMD 的代码中。 ES6模块支持JavaScript标准化的ECMA团队决定解决模块问题，兼容同步和异步操作模式。","categories":[{"name":"模块","slug":"模块","permalink":"https://1518277259.github.io/categories/%E6%A8%A1%E5%9D%97/"}],"tags":[{"name":"模块","slug":"模块","permalink":"https://1518277259.github.io/tags/%E6%A8%A1%E5%9D%97/"}]},{"title":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","date":"2022-04-15T01:37:43.000Z","updated":"2022-04-15T01:38:33.621Z","comments":true,"path":"2022/04/15/深拷贝和浅拷贝/","link":"","permalink":"https://1518277259.github.io/2022/04/15/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"浅拷贝只复制引用，而未复制真正的值 1234567891011121314151617const originArray = [1,2,3,4,5];const originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const cloneArray = originArray;const cloneObj = originObj;console.log(cloneArray); // [1,2,3,4,5]console.log(originObj); // &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:Array[3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;cloneArray.push(6);cloneObj.a = &#123;aa:&#x27;aa&#x27;&#125;;console.log(cloneArray); // [1,2,3,4,5,6]console.log(originArray); // [1,2,3,4,5,6]console.log(cloneObj); // &#123;a:&#123;aa:&#x27;aa&#x27;&#125;,b:&#x27;b&#x27;,c:Array[3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;console.log(originArray); // &#123;a:&#123;aa:&#x27;aa&#x27;&#125;,b:&#x27;b&#x27;,c:Array[3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125; 深拷贝深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。 实现深拷贝的两种方法JSON.stringify&#x2F;parse的方法 如果对象含有一个函数时，不能用这个方法进行深拷贝，因为undefine、function、symbol会在转换过程中被忽略 1234567891011121314const originArray = [1,2,3,4,5];const cloneArray = JSON.parse(JSON.stringify(originArray));console.log(cloneArray === originArray); // falseconst originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const cloneObj = JSON.parse(JSON.stringify(originObj));console.log(cloneObj === originObj); // falsecloneObj.a = &#x27;aa&#x27;;cloneObj.c = [1,1,1];cloneObj.d.dd = &#x27;doubled&#x27;;console.log(cloneObj); // &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;console.log(originObj); // &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;; 递归的方法 1234567891011121314function deepClone(source)&#123; const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象 for(let keys in source)&#123; // 遍历目标 if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === &#x27;object&#x27;)&#123; // 如果值是对象，就递归一下 targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; // 如果不是，就直接赋值 targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125; 总结 赋值运算符 &#x3D; 实现的是浅拷贝，只拷贝对象的引用值； JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”； JSON.stringify 实现的是深拷贝，但是对目标对象有要求； 若想真正意义上的深拷贝，请递归。","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"Promise","slug":"Promise","date":"2022-04-15T01:14:04.000Z","updated":"2022-04-15T01:15:12.696Z","comments":true,"path":"2022/04/15/Promise/","link":"","permalink":"https://1518277259.github.io/2022/04/15/Promise/","excerpt":"","text":"定义Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 状态 在 pending 状态，promise 可以切换到 fulfilled 或 rejected。 在 fulfilled 状态，不能迁移到其它状态，必须有个不可变的 value。 在 rejected 状态，不能迁移到其它状态，必须有个不可变的 reason。 12345678910111213141516171819202122232425function MyPromise(fn) &#123; let self = this; // 缓存当前promise实例 self.value = null; //成功时的值 self.error = null; //失败时的原因 self.onFulfilled = null; //成功的回调函数 self.onRejected = null; //失败的回调函数 function resolve(value) &#123; self.value = value; self.onFulfilled(self.value);//resolve时执行成功回调 &#125; function reject(error) &#123; self.error = error; self.onRejected(self.error)//reject时执行失败回调 &#125; fn(resolve, reject);&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; //在这里给promise实例注册成功和失败回调 this.onFulfilled = onFulfilled; this.onRejected = onRejected;&#125;module.exports = MyPromise","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"原型和原型链","slug":"原型和原型链-1","date":"2022-04-14T02:19:01.000Z","updated":"2022-04-14T03:07:14.043Z","comments":true,"path":"2022/04/14/原型和原型链-1/","link":"","permalink":"https://1518277259.github.io/2022/04/14/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-1/","excerpt":"","text":"原型 原型链每个对象拥有一个原型对象，通过 __proto__ 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。 小结 Symbol 作为构造函数来说并不完整，因为不支持语法 new Symbol()，但其原型上拥有 constructor 属性，即 Symbol.prototype.constructor。 引用类型 constructor 属性值是可以修改的，但是对于基本类型来说是只读的，当然 null 和 undefined 没有 constructor 属性。 __proto__ 是每个实例上都有的属性，prototype 是构造函数的属性，这两个并不一样，但 p.__proto__ 和 Parent.prototype 指向同一个对象。 __proto__ 属性在 ES6 时被标准化，但因为性能问题并不推荐使用，推荐使用 Object.getPrototypeOf()。 每个对象拥有一个原型对象，通过 __proto__ 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null，这就是原型链。","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"call、apply、bind简介","slug":"call、apply、bind简介","date":"2022-04-13T01:34:55.000Z","updated":"2022-04-13T01:35:38.711Z","comments":true,"path":"2022/04/13/call、apply、bind简介/","link":"","permalink":"https://1518277259.github.io/2022/04/13/call%E3%80%81apply%E3%80%81bind%E7%AE%80%E4%BB%8B/","excerpt":"","text":"callcall 是属于所有 Function 的方法，也就是 Function.prototype.call。 12fun.call(thisArg[,arg1[,arg2,…]]); 使用 call 调用函数并且指定 this123456789var obj = &#123; a: 1&#125;function foo(b, c)&#123; this.b = b; this.c = c; console.log(this.a + this.b + this.c);&#125;foo.call(obj,2,3); // 6 call 实现继承12345678910111213141516function Person(name, age)&#123; this.name = name; this.age = age; this.say = function()&#123; console.log(this.name + &quot;:&quot; + this.age); &#125;&#125;function Student(name, age, job)&#123; Person.call(this, name ,age); this.job = job; this.say = function()&#123; console.log(this.name + &quot;:&quot; + this.age + &quot; &quot; + this.job); &#125;&#125;var me = new Student(&quot;axuebin&quot;,25,&quot;FE&quot;);console.log(me.say()); // axuebin:25 FE applyapply 也是属于所有 Function 的方法，也就是 Function.prototype.apply。 1fun.apply(thisArg, [argsArray]) 和 call 用法一样，只是参数不同，call 的参数是列表，将每个参数都列出来；apply 的参数是数组，将每个参数放到一个数组中 完整的 apply1234567891011121314151617Function.prototype.myApply=function(context)&#123; // 获取调用`myApply`的函数本身，用this获取，如果context不存在，则为window var context = context || window; var fn = Symbol(); context[fn] = this; //获取传入的数组参数 var args = arguments[1]; if (args == undefined) &#123; //没有传入参数直接执行 // 执行这个函数 context[fn]() &#125; else &#123; // 执行这个函数 context[fn](...args); &#125; // 从上下文中删除函数引用 delete context.fn;&#125; bindbind()方法创建一个新的函数,当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 12fun.bind(thisArg[, arg1[, arg2[, ...]]]) 例子： 12345678910function Person(name)&#123; this.name = name; this.say = function()&#123; setTimeout(function()&#123; console.log(&quot;hello &quot; + this.name); &#125;.bind(this),1000) &#125;&#125;var person = new Person(&quot;axuebin&quot;);person.say(); //hello axuebin 总结 三者都是用来改变函数的 this 指向 三者的第一个参数都是 this 指向的对象 bind 是返回一个绑定函数可稍后执行，call、apply 是立即调用 三者都可以给定参数传递 call 给定参数需要将参数全部列出，apply 给定参数数组","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"执行上下文、作用域链、闭包","slug":"执行上下文、作用域链、闭包","date":"2022-04-12T06:26:26.000Z","updated":"2022-04-12T06:30:59.164Z","comments":true,"path":"2022/04/12/执行上下文、作用域链、闭包/","link":"","permalink":"https://1518277259.github.io/2022/04/12/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/","excerpt":"","text":"执行上下文执行上下文是评估和执行 JavaScript 代码的环境的抽象概念 类型 全局执行上下文 12它创建会执行两件事：创建一个全局的window对象，并设置this的值等于这个全局的对象。一个程序只会有一个全局对象 函数执行上下文 12每个函数都有它自己的执行上下文，不过是在函数被调用时创建的；this的值取决于该函数是怎样被调用的，如果是被一个对象引用调用，指向这个对象，否则指向全局对象 Eval 函数执行上下文 1执行在 eval 函数内部的代码也会有它属于自己的执行上下文 执行顺序当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。 作用域作用域决定这个变量的生命周期及其可见性。 当我们创建了一个函数或者 {} 块，就会生成一个新的作用域 作用域链当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"在地址栏里输入一个地址回车会发生哪些事情","slug":"在地址栏里输入一个地址回车会发生哪些事情","date":"2022-04-11T03:36:45.000Z","updated":"2022-04-11T03:38:52.997Z","comments":true,"path":"2022/04/11/在地址栏里输入一个地址回车会发生哪些事情/","link":"","permalink":"https://1518277259.github.io/2022/04/11/%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%87%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%E5%9B%9E%E8%BD%A6%E4%BC%9A%E5%8F%91%E7%94%9F%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/","excerpt":"","text":"解析 URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。 缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。 DNS 解析：下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。 获取 MAC 地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 TCP 三次握手：下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。 HTTPS 握手：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。 返回数据：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 页面渲染：浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。 TCP 四次挥手：最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"TCP和UDP的区别","slug":"TCP和UDP的区别","date":"2022-04-11T03:30:48.000Z","updated":"2022-04-11T03:31:31.095Z","comments":true,"path":"2022/04/11/TCP和UDP的区别/","link":"","permalink":"https://1518277259.github.io/2022/04/11/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"TCP UDP TCP 是面向连接的协议 UDP 的无连接的协议 TCP 在发送数据前需要建立连接 UDP 无需建立连接就可以发送大量数据 TCP 回按照特定的顺序重新排列数据包 UDP 数据包没有固定顺序，所有数据包相互独立 TCP 传输速度比较慢 UDP 的传输会更快 TCP 的头部字节有 20 字节 UDP 的头部字节只需要 8 个字节 TCP 是重量级的，在发送数据前需要进行三次握手建立连接 UDP 是轻量级的，没有跟踪链接，消息排序 TCP 会进行错误校验，并进行错误恢复 UDP 也会进行错误检查，但会丢掉错误的数据包 TCP 有发送确认 UDP 没有发送确认 TCP 会使用握手协议 无握手协议 TCP 是可靠的，可以确保将数据传送到路由器 在 UDP 中不能确保数据传送到目标","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"GEI和POST的区别","slug":"GEI和POST的区别","date":"2022-04-11T03:03:49.000Z","updated":"2022-04-11T03:29:41.055Z","comments":true,"path":"2022/04/11/GEI和POST的区别/","link":"","permalink":"https://1518277259.github.io/2022/04/11/GEI%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"数据传输方式不同：GET 请求通过 URL 传输数据，而 POST 的数据通过请求体传输。 安全性不同：POST 的数据因为在请求主体内，所以有一定的安全性保证，而 GET 的数据在 URL 中，通过历史记录，缓存很容易查到数据信息。 数据类型不同：GET 只允许 ASCII 字符，而 POST 无限制 GET 无害： 刷新、后退等浏览器操作 GET 请求是无害的，POST 可能重复提交表单 特性不同：GET 是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而 POST 是非安全非幂等","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"HTTP和HTTPS的区别","slug":"HTTP和HTTPS的区别","date":"2022-04-11T02:54:56.000Z","updated":"2022-04-11T03:03:29.058Z","comments":true,"path":"2022/04/11/HTTP和HTTPS的区别/","link":"","permalink":"https://1518277259.github.io/2022/04/11/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"http 是客户端和服务器请求和应答的标准的(TCP)超文本传输协议，使浏览器更高效，网络传输减少；https 简单来说就是 http+SSL，作用 1 是建立信息安全通道，保证数据传输安全，2 是确认网站真实性 https 协议需要证书，一般免费证书少，需要一定费用； http 是超文本传输协议，信息是明文传输；https 则是具有 ssl 加密的传输协议 连接方式不同，端口不同，http:80 https:443 http 连接是无状态的；https 协议是有 SSL+Http 协议构成的可进行加密传输、身份认证的网络协议，比 http 协议更安全。","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"HTTP状态码简介","slug":"HTTP状态码简介","date":"2022-04-11T02:36:27.000Z","updated":"2022-04-11T02:50:04.481Z","comments":true,"path":"2022/04/11/HTTP状态码简介/","link":"","permalink":"https://1518277259.github.io/2022/04/11/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一、1 开头1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 二、2 开头2xx (成功)表示成功处理了请求的状态代码 200 (成功) 服务器已成功处理了请求，通常表示服务器提供了请求的网关 201 (已创建) 请求成功并且服务器创建了新的资源。 202 (已接受) 服务器已接受请求，但尚未处理。 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。 206 (部分内容) 服务器成功处理了部分 GET 请求。 三、3 开头3xx (重定向) 表示要完成请求，需要进一步操作。 通常这些状态代码用来重定向 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 四、4 开头4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理 400 (错误请求) 服务器不理解请求的语法。 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 (禁止) 服务器拒绝请求。 404 (未找到) 服务器找不到请求的网页。 405 (方法禁用) 禁用请求中指定的方法。 406 (不接受) 无法使用请求的内容特性响应请求的网页。 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。 408 (请求超时) 服务器等候请求时发生超时。 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 (未满足期望值) 服务器未满足”期望”请求标头字段的要求。 五、5 开头5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。 六、适用场景 100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输 206：一般用来做断点续传，或者是视频文件等大文件的加载 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分 400：参数有误，请求无法被服务器识别 403：告诉客户端禁止访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时 503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503 504：网关超时","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2022-04-11T02:24:51.000Z","updated":"2022-04-11T02:33:56.133Z","comments":true,"path":"2022/04/11/git常用命令/","link":"","permalink":"https://1518277259.github.io/2022/04/11/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git branch 查看本地所有分支git status 查看当前状态git commit 提交 git branch -a 查看所有分支git branch -r 查看远程所有分支git commit -am ‘注释’ 提交并添加注释git push origin master 将文件推送到服务器git remote show origin 显示远程库 origin 中的资源git checkout –track origin&#x2F;dev 切换到远程 dev 分支git checkout -D master dev 删除本地库 devgit checkout -b dev 建立一个新的本地分支git merge origin&#x2F;dev 将分支 dev 与当前分支合并git checkout dev 切换成本地分支git remote show 查看远程库git add . 将文件添加到本地库git rm 文件名(包括路径) 从 git 删除指定文件 git clone 从服务器上将代码拉下来git config –list 看所有用户git ls-files 看已经被提交的git log 看 commit 的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm –cached a.a 移除文件(只从暂存区中删除)git commit -m “remove” 移除文件(从 Git 中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff –cached 或 $ git diff –staged 查看尚未提交的更新git stash push 将文件给 push 到一个临时空间中git stash pop 将文件从临时空间 pop 下来","categories":[{"name":"git","slug":"git","permalink":"https://1518277259.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://1518277259.github.io/tags/git/"}]},{"title":"Vue脚手架创建","slug":"Vue脚手架创建","date":"2022-03-31T07:09:43.000Z","updated":"2022-03-31T07:10:50.857Z","comments":true,"path":"2022/03/31/Vue脚手架创建/","link":"","permalink":"https://1518277259.github.io/2022/03/31/Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA/","excerpt":"","text":"Vue是什么Vue是一套用于构建用户界面的渐进式Javascript框架 Vue的特点 采用组件化模式，提高代码复用率，让代码更好维护 采用声明式编码，让开发人员无需操作DOM，提高开发效率 使用虚拟DOM和diff算法，尽量复用DOM节点 Vue脚手架网速原因先配置淘宝镜像 1npm config set registry https://registry.npm.taobao.org 全局安装@vue&#x2F;cli 1npm install -g @vue/cli 切换到你要创建的目录，使用命令行创建项目XXX 1vue create XXX 启动项目 123npm installnpm run dev/serve 使用命令查看项目的webpack打包配置 1vue inspect &gt; output.js Vue3 使用Vite创建1234567891011// 创建工程npm init vite-app &lt;project-name&gt;// 进入工程目录cd &lt;project-name&gt;// 安装依赖npm install// 运行npm run dev","categories":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/tags/vue/"}]},{"title":"元素居中","slug":"元素居中","date":"2022-03-29T11:05:26.000Z","updated":"2022-03-29T11:13:04.002Z","comments":true,"path":"2022/03/29/元素居中/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/","excerpt":"","text":"水平居中1.行内元素水平居中利用 text-align: center 可以实现在块级元素内部的行内元素水平居中。 此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。 12345.parent&#123; //在父容器设置 text-align:center; &#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent&#123; text-align:center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 2.块级元素的水平居中①、 将该块级元素左右外边距margin-left和margin-right设置为auto 1234.child&#123; width: 100px;//确保该块级元素定宽 margin:0 auto;&#125; ②、使用table+margin 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; ③、使用absolute+transform 12345678910111213&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position:absolute; left:50%; transform:translateX(-50%); &#125; .parent &#123; position:relative; &#125;&lt;/style&gt; ④、使用flex+justify-content 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content:center; &#125;&lt;/style&gt; ⑤、使用flex+margin 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 3、多块级元素水平居中①、利用flex布局 1234#container &#123; display: flex; justify-content: center;&#125; ②、利用inline-block 123456.container &#123;text-align: center;&#125;.inline-block &#123;display: inline-block;&#125; 4、浮动元素水平居中①、定宽的非浮动元素 12345678.child &#123; position:relative; left:50%; margin-left:-250px;&#125;&lt;div class=&quot;parent&quot;&gt; &lt;span class=&quot;child&quot; style=&quot;float: left;width: 500px;&quot;&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; ②、不定宽的浮动元素 1234567891011121314&lt;div class=&quot;box&quot;&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%;&#125;p&#123; float:left; position:relative; right:50%;&#125; ③、通用办法flex布局(不管是定宽还是不定宽) 123456789101112.parent &#123; display:flex; justify-content:center;&#125;.chlid&#123; float: left; width: 200px;//有无宽度不影响居中&#125;&lt;div class=&quot;parent&quot;&gt; &lt;span class=&quot;chlid&quot;&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 5、绝对定位元素水平居中123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt; .parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width: 200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 垂直居中1.单行内联元素垂直居中1234567891011&lt;div id=&quot;box&quot;&gt; &lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 2.多行内联元素垂直居中①、利用flex布局（flex） 123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;p&gt;Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is.&lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; ②、利用表布局（table） 1234567891011121314151617&lt;div class=&quot;parent&quot;&gt; &lt;p class=&quot;child&quot;&gt;The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know.&lt;/p&gt;&lt;/div&gt; &lt;style&gt; .parent &#123; display: table; height: 140px; border: 2px dashed #f69c55; &#125; .child &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 3 块级元素垂直居中①、使用absolute+负margin(已知高度宽度) 12345678910111213&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123;position: relative;&#125;.child &#123;position: absolute;top: 50%;height: 100px;margin-top: -50px;&#125; ②、使用absolute+transform 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123;position: relative;&#125;.child &#123;position: absolute;top: 50%;transform: translateY(-50%);&#125; ③、使用flex+align-items 12345678&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center;&#125; ④、使用table-cell+vertical-align 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 水平垂直居中1、绝对定位与负边距实现（已知高度宽度）123456789101112131415161718// css部分 #container &#123; position: relative; &#125; #center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; &#125; // html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id=&#x27;container&#x27;&gt; &lt;div id=&#x27;center&#x27; style=&quot;width: 100px;height: 100px;background-color: #666&quot;&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 2、绝对定位与margin:auto（已知高度宽度）123456789101112#container &#123; position: relative; height:100px;//必须有个高度 &#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 &#125; 3、绝对定位+CSS3(未知元素的高宽)12345678910#container &#123; position: relative; &#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; 4、flex布局1234567#container &#123;//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; &#125; 5、flex&#x2F;grid与margin:auto(最简单写法)12345678#container &#123; height: 100vh;//必须有高度 display: grid; &#125;#center &#123; margin: auto; &#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"实现三栏布局的方法","slug":"实现三栏布局的方法","date":"2022-03-29T08:53:29.000Z","updated":"2022-03-29T08:54:34.102Z","comments":true,"path":"2022/03/29/实现三栏布局的方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"浮动布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style media=&quot;screen&quot;&gt; html * &#123; padding: 0; margin: 0; &#125; .layout article div &#123; min-height: 150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--浮动布局 --&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;style media=&quot;screen&quot;&gt; .layout.float .left &#123; float: left; width: 300px; background: red; &#125; .layout.float .center &#123; background: yellow; &#125; .layout.float .right &#123; float: right; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; // 右栏部分要写在中间内容之前 &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等。 绝对布局123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right&gt;div&#123; position: absolute;//三块都是绝对定位 &#125; .left &#123; left:0; width: 300px; background: red; &#125; .center &#123; right: 300px; left: 300px;//离左右各三百 background: yellow; &#125; .right &#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; 绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。 flex布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: flex; &#125; .left &#123; width: 300px; background: red; &#125; .center &#123; background: yellow; flex: 1; &#125; .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; lexbox布局是css3里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用flexbox。 flexbox的缺点就是IE10开始支持，但是IE10的是-ms形式的。 表格布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: table; height: 150px; width: 100%; &#125; .left-center-right&gt;div &#123; display: table-cell; &#125; .left &#123; width: 300px; background: red; &#125; .center &#123; background: yellow; &#125; .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; 表格布局的兼容性很好(见下图)，在flex布局不兼容的时候，可以尝试表格布局。当内容溢出时会自动撑开父元素。 表格布局也是有缺陷:①无法设置栏边距；②对seo不友好；③当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。 网格布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: grid; width: 100%; grid-template-columns: 300px auto 300px; grid-template-rows: 150px; //行高 &#125; .left &#123; background: red; &#125; .center &#123; background: yellow; &#125; .right &#123; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; CSS Grid是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让Web设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"Flex布局","slug":"Flex布局","date":"2022-03-29T06:37:18.000Z","updated":"2022-03-29T06:41:36.594Z","comments":true,"path":"2022/03/29/Flex布局/","link":"","permalink":"https://1518277259.github.io/2022/03/29/Flex%E5%B8%83%E5%B1%80/","excerpt":"","text":"Flex 基本概念在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴 Flex 容器实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。如果你使用块元素如 div，你就可以使用 flex，而如果你使用行内元素，你可以使用 inline-flex。 需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 Flex属性1. flex-direction决定主轴的方向(即项目的排列方向) 1234567.container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; row，主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端column：主轴为垂直方向，起点在上沿column-reverse：主轴为垂直方向，起点在下沿 2. flex-wrap:决定容器内项目是否可换行 1234567891011.container &#123; flex-wrap: nowrap | wrap | wrap-reverse; &#125; 默认值：nowrap 不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。wrap：项目主轴总尺寸超出容器时换行，第一行在上方；wrap-reverse：换行，第一行在下方 3. flex-flow:flex-direction 和 flex-wrap 的简写形式 123456.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 默认值为: row nowrap，感觉没什么卵用，老老实实分开写就好了。这样就不用记住这个属性了。 4. justify-content：定义了项目在主轴的对齐方式。 12345678910111213.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 默认值: flex-start 左对齐flex-end：右对齐center：居中space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 5. align-items:定义了项目在交叉轴上的对齐方式 1234567891011.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐flex-end：交叉轴的终点对齐center：交叉轴的中点对齐baseline: 项目的第一行文字的基线对齐 6. align-content:定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用 12345678910111213.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：轴线全部在交叉轴上的起点对齐flex-end：轴线全部在交叉轴上的终点对齐center：轴线全部在交叉轴上的中间对齐space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"CSS高度塌陷","slug":"CSS高度塌陷","date":"2022-03-29T06:13:43.000Z","updated":"2022-03-29T11:14:13.490Z","comments":true,"path":"2022/03/29/CSS高度塌陷/","link":"","permalink":"https://1518277259.github.io/2022/03/29/CSS%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7/","excerpt":"","text":"1.什么是高度塌陷当父元素不设置高度的时候，靠子元素撑大；当子元素浮动后，父元素的高度就会塌陷；父元素下面的元素就会向上移动，导致整个页面混乱。 1234&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; 12345678910111213.box1 &#123; border: 10px red solid; &#125;.box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125;.box3 &#123; height: 100px; background-color: green; &#125; 2.解决方法方法一：给父元素设置高度，固定高度后父元素的高度无法适应子元素的高度。弊端： 不能让元素自适应 12345.box1 &#123; border: 10px red solid; height:100px; &#125; 方法二：给父元素设置overflow：hidden，解决高度塌陷并实现自适应，弊端： 只要里面的内容或元素超出父元素以外就会被隐藏。 1234.box1 &#123; border: 10px red solid; overflow: hidden; &#125; 方法三：在浮动元素下面添加一个空白元素，并给它设置一哈属性；弊端： 会添加很多空标记，增加结构负担，产生代码冗余 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; .clear_fix&#123; /*空白div的属性*/ clear:both; /*清除两侧浮动*/ height:0; overflow:hidden; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clear_fix&quot;&gt;&lt;/div&gt; /*添加空白div*/ &lt;/div&gt; &lt;/body&gt; 方法四：给父元素添加display:table；让父元素转换元素类型和表格一样弊端： 会改变当前元素的元素类型 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; display: table; /* 改变元素类型为表格 */ &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 方法五：万能清除法通过after伪类元素添加一个空白的块元素，css添加下列属性，并给要清除的div加上clear_fix的类名，无副作用。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; .clear_fix:after &#123; /* 要加的属性 */ content: &quot;&quot;; /* 添加内容 */ clear: both; /* 清楚两侧浮动 */ display: block; /* 转换元素类型为块元素 */ height: 0; overflow: hidden; /* 溢出隐藏属性 */ visibility: hidden;/* 隐藏属性 */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1 clear_fix&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"搭建博客网站","slug":"搭建博客网站","date":"2022-03-29T06:09:54.000Z","updated":"2022-04-14T03:02:59.648Z","comments":true,"path":"2022/03/29/搭建博客网站/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","excerpt":"","text":"基础配置1234567npm i -g hexohexo initnpm i hexo-serverhexo-server 主题1.获取模板 1hexo.theme.getView(path); 设置模板 1hexo.theme.setView(path, data); 3.移除模板 1hexo.theme.removeView(path); 配置完成打包上传123hexo clean //删除上次打包hexo generate //打包hexo deploy /上传","categories":[{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/tags/hexo/"}]},{"title":"字符串常用操作方法","slug":"字符串常用操作方法","date":"2022-03-29T06:05:28.000Z","updated":"2022-03-29T11:14:05.200Z","comments":true,"path":"2022/03/29/字符串常用操作方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/","excerpt":"","text":"一. length JS中的字符串有一个length属性，该属性可以用来获取字符串的长度 12const str = &quot;hello&quot;str.length //输出结果5 二.获取字符串指定位置的值 charAt() 方法获取到的是指定位置的字符 charCodeAt()方法获取的是指定位置字符的Unicode值 charAt() 12345const str = &quot;hello&quot;str.chatAt(1) // 输出结果：estr[1] // 输出结果：estr.charAt(5) // 输出结果：&quot;&quot;str[5] // 输出结果：undefine charCodeAt() 12let str = &quot;abcdefg&quot;console.log(str.charCodeAt(1)) // &quot;b&quot;--&gt; 98 三.检索字符串是否包含特定序列 indexOf() 查找某个字符，有则返回第一次匹配到的位置，否则返回-1 123456789string.indexOf(searchvalue,fromindex)searchvalue:必需，规定需检索的字符串值fromindex：可选的整数参数，规定在字符串开始检索的位置。合法取值范围是0-string.length-1.如省略，则从字符串的首字符开始检索let str = &quot;abcdefgabc&quot;console.log(str.indexOf(&quot;a&quot;)) // 输出结果：0console.log(str.indexOf(&quot;z&quot;)) // 输出结果：-1console.log(str.indexOf(&quot;c&quot;,4)) //输出结果：9 lastIndexOf() 查找某个字符，有则返回最后一次匹配的位置，否则返回-1 123let str = “abcabc”console.log(str.lastIndexOf(&quot;a&quot;)) // 输出结果：3console.log(str.lastIndexOf(&quot;z&quot;)) // 输出结果：-1 includes() 该方法用于判断字符串是否包含指定的子字符串，如果找到指定的子字符串，返回true，否则返回false 123456789string.includes(searchvalue,start)searchvalue:必需，要查找的字符串start:可选，设置从那个位置开始查找，默认为0let str = &quot;Hello world&quot;str.includes(&quot;o&quot;) // 输出结果:truestr.includes(&quot;z&quot;) // 输出结果：falsestr.includes(&quot;e&quot;,2) // 输出结果：false startsWith() 该方法用于检测字符串是否以指定的子字符串开始。如果是以指定的子字符串开头返回 true，否则 false。 123456let str = &#x27;Hello world!&#x27;;str.startsWith(&#x27;Hello&#x27;) // 输出结果：truestr.startsWith(&#x27;Helle&#x27;) // 输出结果：falsestr.startsWith(&#x27;wo&#x27;, 6) // 输出结果：true endsWith() 该方法用来判断当前字符串是否是以指定的子字符串结尾。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。 12345678910string.endsWith(searchvalue, length)searchvalue：必需，要搜索的子字符串；length： 设置字符串的长度，默认值为原始字符串长度 string.length。let str = &#x27;Hello world!&#x27;;str.endsWith(&#x27;!&#x27;) // 输出结果：truestr.endsWith(&#x27;llo&#x27;) // 输出结果：falsestr.endsWith(&#x27;llo&#x27;, 5) // 输出结果：true 四、连接多个字符串concat()123456string.concat(string1, string2, ..., stringX)let str = &quot;abc&quot;;console.log(str.concat(&quot;efg&quot;)); //输出结果：&quot;abcefg&quot;console.log(str.concat(&quot;efg&quot;,&quot;hijk&quot;)); //输出结果：&quot;abcefghijk&quot; 五、字符串分割成数组split()用于把一个字符串分割成字符串数组，该方法不会改变原始字符串 12345678string.split(separator,limit)separator:必需。字符串或正则表达式，从该参数指定的位置分割stringlimit：可选，该参数可指定返回的数组的最大长度，如果设置了该参数，返回的子字符串不会多于这个参数指定的数组；如果没有设置该参数，整个字符串都会被分割，不考虑他的长度let str = &quot;abcdef&quot;;str.split(&quot;c&quot;); // 输出结果：[&quot;ab&quot;, &quot;def&quot;]str.split(&quot;&quot;, 4) // 输出结果：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 六、截取字符串 slice() 用于提取字符串的某一部分，并以新的字符串返回提取的部分,该方法返回的子串包括开始处的字符，但不包括结束处的字符。 1234567891011string.slice(start,end)start:必需，要截取的片段的起始下标，第一个字符串位置为0，如果为负数，则从尾部开始截取end: 可选，要截取的片段结尾的下标，若未指定此参数，则要提取的字串包含start到原字符串结尾的字符串。如果是负数，则从字符串的尾部开始算起的位置let str= &quot;abcdefg&quot;str.slice(1,6) // 输出结果：“bcdef”str.slice(1) // 输出结果：“bcdefg”str.slice() // 输出结果：“abcdefg”str.slice(-2) //输出结果：“fg”str.slice(6,1) //输出结果：&quot;&quot; 2.substr()用于在字符串中抽取从开始下标开始的指定数目的字符。 123456789string.substr(start,length)start:必需，要抽取的字串的起始下标。必须是数值。如果是负数，则该参数声明从字符串的尾部开始算起的位置length：可选，子串中字符数。如果省略了该参数，则返回从stringObject的开始位置到结尾的字串let str = &quot;abcdefg&quot;str.substr(1,6) //输出结果：“bcdefg”str.substr(1) // 输出结果：“bcdefg”str.substr(-1) //输出结果：“g” 3.substring()用于提取字符串中介于两个指定下标之间的字符 123456789101112string.substring(from,to)from:必需，一个非负的整数，规定要提取的子串的第一个字符在string的位置to：可选，一个非负的整数，比要提取的子串的最后一个字符在string中的位置多1。如省略，返回的子串会一直到字符串的结尾let str = &quot;abcdefg&quot;str.substring(1,6) //输出结果：“bcdef”str.substring(1) //输出结果：“bcdefg”str.substring() // 输出结果：“abcdefg”str.substring(6,1) // 输出结果：“bcdef”str.substring(-1) // 输出结果：&quot;abcdefg&quot; 七、字符串大小写转换 toLowerCase()用于把字符串转换成小写 12let str = &quot;adABDndj&quot;str.toLowerCase(); //输出结果：“adabdndj” 2.toUpperCase()用于将字符串转换成大写 12let str = “asdfGH”str.toUpperCase(); //输出结果：“ASDFGH” 八、字符串模式匹配1.replace()用于在字符串中用一些字符串替换名一些字符串，或者替换一个与正则表达式匹配的子串 1234567891011string.replace(searchvalue,newvalue)searchvalue:必需，规定子字符串或要替换的模式的RwgExp对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换成RegExp对象newvalue：必需，一个字符串的值let str = “abcdef”str.replace(&quot;c&quot;,&quot;a&quot;) // 输出结果：abadeflet str=&quot;Mr Blue has a blue house and a blue car&quot;;str.replace(/blue/gi, &quot;red&quot;); // 输出结果：&#x27;Mr red has a red house and a red car&#x27; match() 用于在字符串内检索特定的值，或找到一个或多个正则表达式的匹配 1234string.match(regexp)let str = &quot;abcdef&quot;console.log(str.match(&quot;c&quot;)) // // [&quot;c&quot;, index: 2, input: &quot;abcdef&quot;, groups: undefined] search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。只会返回第一次匹配成功的结果;如果没有找到任何匹配的子串，则返回 -1。 12345string.search(searchvalue)let str = &quot;abcdef&quot;;str.search(/bcd/) // 输出结果：1 九、移除字符串首尾空白符 trim() 用于移除字符串首尾空白符，该方法不会改变原始字符串 123let str = &quot; abcdef &quot;str.trim() // 输出结果：&quot;abcdef&quot; trimStart() trimStart() 方法的的行为与trim()一致，不过会返回一个从原始字符串的开头删除了空白的新字符串，不会修改原始字符串： 123const s = &#x27; abc &#x27;;s.trimStart() // &quot;abc &quot; trimEnd() trimEnd() 方法的的行为与trim()一致，不过会返回一个从原始字符串的结尾删除了空白的新字符串，不会修改原始字符串： 1234const s = &#x27; abc &#x27;;s.trimEnd() // &quot; abc&quot; 十、获取字符串本身 valueOf() 返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。 12let str = &quot;abcdef&quot;console.log(str.valueOf()) // &quot;abcdef&quot; toString() 返回字符串对象本身 12let str = &quot;abcdef&quot;console.log(str.toString()) // &quot;abcdef&quot; 十一、重复一个字符串repeat()返回一个新字符串，表示将原字符串重复n次： 123&#x27;x&#x27;.repeat(3) // 输出结果：&quot;xxx&quot;&#x27;hello&#x27;.repeat(2) // 输出结果：&quot;hellohello&quot;&#x27;na&#x27;.repeat(0) // 输出结果：&quot;&quot; 注意：如果参数是小数，向下取整；如果参数是负数或Infinity，会报错 十二、补齐字符串长度 padStart() 用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 1234567&#x27;x&#x27;.padStart(1, &#x27;ab&#x27;) // &#x27;x&#x27;&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;) // &#x27;ababx&#x27;&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;) // &#x27;abax&#x27;&#x27;x&#x27;.padStart(4) // &#x27; x&#x27;&quot;1&quot;.padStart(3, &#x27;0&#x27;) // 输出结果： &#x27;001&#x27;&quot;15&quot;.padStart(3, &#x27;0&#x27;) // 输出结果： &#x27;015&#x27; padEnd() 用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串： 123&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;) // &#x27;xabab&#x27;&#x27;x&#x27;.padEnd(4, &#x27;ab&#x27;) // &#x27;xaba&#x27; 十三、字符串转为数字1.parseInt() 用于可解析一个字符串，并返回一个整数 12345678910111213141516171819202122parseInt(string, radix)string:必需，要被解析的字符串radix：可选，表示要解析的数字的基数。parseInt(&quot;10&quot;); // 输出结果：10parseInt(&quot;17&quot;,8); // 输出结果：15 (8+7)parseInt(&quot;010&quot;); // 输出结果：10 或 8parseInt(&quot;0x10&quot;) // 输出结果：16parseInt(&quot;50&quot;, 1) // 输出结果：NaNparseInt(&quot;50&quot;, 40) // 输出结果：NaNparseInt(&quot;40 4years&quot;) // 输出结果：40parseInt(&quot;new100&quot;) // 输出结果：NaNparseInt(&quot; 60 &quot;) // 输出结果： 60 parseFloat(string) 可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 123456parseFloat(&quot;10.00&quot;) // 输出结果：10.00parseFloat(&quot;10.01&quot;) // 输出结果：10.01parseFloat(&quot;-10.01&quot;) // 输出结果：-10.01parseFloat(&quot;40.5 years&quot;) // 输出结果：40.5","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"数组Array的常用方法","slug":"数组Array的常用方法","date":"2022-03-29T03:36:26.000Z","updated":"2022-03-29T11:13:50.725Z","comments":true,"path":"2022/03/29/数组Array的常用方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E6%95%B0%E7%BB%84Array%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Array.map()将数组中的每一个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组 12345let arr = [1, 2, 3, 4, 5];let newArr = arr.map(x =&gt; x*2);// arr = [1, 2, 3, 4, 5] 原数组保持不变// newArr = [2, 4, 6, 8, 10] 返回新数组 Array.forEach()将数组中的每个元素执行传进提供的函数，没有返回值 12345let arr = [1, 2, 3, 4, 5];arr.forEach(x =&gt; x*2);console.log(arr)// arr = [1, 2, 3, 4, 5] 数组改变,注意和map区分 Array.filter()将所有元素进行判断，将满足条件的元素作为一个新的数组返回 1234let arr = [1, 2, 3, 4, 5];const isBigEnough = value =&gt; value &gt;= 3;let newArr = arr.filter(isBigEnough);// newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组 Array.eveny()将所有的元素进行判断返回一个布尔值，如果所有元素都满足条件，返回true，否则返回false 123456let arr = [1, 2, 3, 4, 5];const isLessThan4 = value =&gt; value &lt; 4;const isLessThan6 = value =&gt; value &lt; 6;arr.every(isLessThan4); // falsearr.every(isLessThan6); // true Array.some()此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false。 123456let arr= [1, 2, 3, 4, 5];const isLessThan4 = value =&gt; value &lt; 4;const isLessThan6 = value =&gt; value &gt; 6;arr.some(isLessThan4); // truearr.some(isLessThan6); // false Array.reduce()所有元素调用返回函数，返回值为最终结果，传入的值必需是函数类型 1234567let arr = [1, 2, 3, 4, 5];const add = (a, b) =&gt; a + b;let sum = arr.reduce(add);// sum = 15 相当于累加的效果// 与之相对应的还有一个 Array.reduceRight() 方法，// 区别是这个是从右向左操作的 Array.push()在数组的后面添加元素，改变了数组的长度 123456var str1 = [12,2,&quot;hello&quot;];var str2 = [43,2,&quot;test&quot;];console.log(str1.push(&quot;你好&quot;)); // 4console.log(str2.push(&quot;hello&quot;,&quot;world&quot;)); // 5console.log(str1); // [12, 2, &quot;hello&quot;,&quot;你好&quot;]console.log(str2); // [43, 2, &quot;test&quot;,&quot;hello&quot;, &quot;world&quot;] Array.pop()在数组后面删除最后一位元素，并返回数组，改变了数组的长度 12345let arr = [1, 2, 3, 4, 5];arr.pop();console.log(arr); // [1, 2, 3, 4]console.log(arr.length); // 4 Array.shift()删除数组的第一个元素，并返回数组，改变数组的长度 12345let arr = [1, 2, 3, 4, 5];arr.shift();console.log(arr); // [2, 3, 4, 5]console.log(arr.length); // 4 Array.unshift()将一个或多个元素添加到数组的开头，并返回数组的长度 1234567var str1 = [12,2,&quot;hello&quot;];var str2 = [43,2,&quot;test&quot;];console.log(str1.unshift(&quot;你好&quot;)); // 4console.log(str2.unshift(&quot;hello&quot;,&quot;world&quot;)); // 5console.log(str1); // [&quot;你好&quot;, 12, 2, &quot;hello&quot;]console.log(str2); // [&quot;hello&quot;, &quot;world&quot;, 43, 2, &quot;test&quot;] Array.isArray()判断一个对象是不是数组，返回是布尔值 123let arr = [1, 2, 3, 4, 5];console.log(arr.isArray()); // true Array.concat()可以将多个数组拼成一个数组 1234let arr1 = [1, 2, 3];arr2 = [4, 5];let arr = arr1.concat(arr2);console.log(arr); // [1, 2, 3, 4, 5] Array.toString()将数组转换成字符串，不会改变原数组 123let arr = [1, 2, 3, 4, 5];let str = arr.toString();console.log(str); // 1,2,3,4,5 Array.join()将数组转成字符串并返回字符串数据，不会改变原来的数组 1234567let arr = [1, 2, 3, 4, 5];let str1 = arr.join();let str2 = arr.join(&#x27;,&#x27;);let str3 = arr.join(&#x27;##&#x27;);console.log(str1); // 12345console.log(str2); // 1,2,3,4,5console.log(str3); // 1##2##3##4##5 Array.splice()Array.splice(开始位置，删除的个数，元素)，万能方法，可以实现增删改 1234567let arr = [1, 2, 3, 4, 5];let arr1 = arr.splice(2, 0 &#x27;haha&#x27;);let arr2 = arr.splice(2, 3);let arr1 = arr.splice(2, 1 &#x27;haha&#x27;);console.log(arr1); // [1, 2, &#x27;haha&#x27;, 3, 4, 5] 新增一个元素console.log(arr2); // [1, 2] 删除三个元素console.log(arr3); // [1, 2, &#x27;haha&#x27;, 4, 5] 替换一个元素 Array.slice()此方法截取指定位置的数组，并返回截取的数组，不会改变原数组。 12345678var arr = [&quot;T1&quot;,&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;];console.log(arr.slice(1,3)); // [&quot;J1&quot;,&quot;L1&quot;]console.log(arr.slice(1)); // [&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;]console.log(arr.slice(-4,-1)); // [&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;]console.log(arr.slice(-2)); // [&quot;L2&quot;,&quot;M1&quot;]console.log(arr.slice(1,-2)); // [&quot;J1&quot;,&quot;L1&quot;]console.log(arr); // [&quot;T1&quot;,&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;] Array.reverse()将数组的数据进行反转，并返回反转后的数组，会改变原数组 123var str1 = [12,2,&quot;hello&quot;];console.log(str1.reverse()); // [&quot;hello&quot;, 2, 12]console.log(str1); // [&quot;hello&quot;, 2, 12] Array.sort()将数组内的数据进行排序，并返回排过序的新数组，会改变原来的数组 1234567var str1 = [12,2,43,5,2,5];var str2 = [92,2,43,&quot;hello&quot;,&#x27;zoom&#x27;,5,2,5];console.log(str1.sort()); // [12, 2, 2, 43, 5, 5]console.log(str1); // [12, 2, 2, 43, 5, 5]console.log(str2.sort()); // [2, 2, 43, 5, 5, 92, &quot;abc&quot;, &quot;hello&quot;, &quot;zoom&quot;]console.log(str2); // [2, 2, 43, 5, 5, 92, &quot;abc&quot;, &quot;hello&quot;, &quot;zoom&quot;] Array.valueOf()返回数组的原始值，一般由js在后台调用，并不显示的出现在代码中 123456var str = [1,2,3];console.log(str.valueOf()); // [1,2,3]console.log(str); // [1,2,3]// 为了证明返回的是数组自身console.log(str.valueOf() == str); // true Array.IndexOf()此方法根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1，找到了指定的数据返回该数据的索引 1234567var str = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;];console.log(str.indexOf(&quot;l&quot;)); // 2console.log(str.indexOf(&quot;l&quot;,3)); // 3console.log(str.indexOf(&quot;l&quot;,4)); // -1console.log(str.indexOf(&quot;l&quot;,-1)); // -1console.log(str.indexOf(&quot;l&quot;,-3)); // 2 Array.includes()用来判断一个数组是否包含一个指定的值，如果是返回true，否则返回false 1234let site = [&#x27;runoob&#x27;, &#x27;google&#x27;, &#x27;taobao&#x27;];console.log(site.includes(&#x27;runoob&#x27;)); // true console.log(site.includes(&#x27;baidu&#x27;)); // false Array.flat()用来实现数据的扁平化 1234let site = [1, 2, [3, 4]];console.log(arr1.flat());// [1, 2, 3, 4]","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://1518277259.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"websocket","slug":"websocket","permalink":"https://1518277259.github.io/categories/websocket/"},{"name":"webpack","slug":"webpack","permalink":"https://1518277259.github.io/categories/webpack/"},{"name":"模块","slug":"模块","permalink":"https://1518277259.github.io/categories/%E6%A8%A1%E5%9D%97/"},{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"},{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"},{"name":"git","slug":"git","permalink":"https://1518277259.github.io/categories/git/"},{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/categories/vue/"},{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"},{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/categories/hexo/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://1518277259.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"websocket","slug":"websocket","permalink":"https://1518277259.github.io/tags/websocket/"},{"name":"webpack","slug":"webpack","permalink":"https://1518277259.github.io/tags/webpack/"},{"name":"模块","slug":"模块","permalink":"https://1518277259.github.io/tags/%E6%A8%A1%E5%9D%97/"},{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"},{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"},{"name":"git","slug":"git","permalink":"https://1518277259.github.io/tags/git/"},{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/tags/vue/"},{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"},{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/tags/hexo/"},{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}