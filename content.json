{"meta":{"title":"ysp博客","subtitle":"风雨同路人","description":"对自己学习和生活的记录","author":"杨书平","url":"https://1518277259.github.io","root":"/"},"pages":[{"title":"about","date":"2022-03-29T08:03:29.000Z","updated":"2022-03-29T08:03:29.379Z","comments":true,"path":"about/index.html","permalink":"https://1518277259.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"浏览器解析","slug":"浏览器解析","date":"2023-02-27T08:24:51.000Z","updated":"2023-03-02T13:28:58.235Z","comments":true,"path":"2023/02/27/浏览器解析/","link":"","permalink":"https://1518277259.github.io/2023/02/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90/","excerpt":"","text":"浏览器解析浏览器打开一个页面需要启动哪些进行 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 渲染机制 解析html，构建DOM树 解析CSS，生成CSSOM树 合并dom树和css规则树，生成render渲染树 根据render渲染树进行布局 调用GPU对渲染树进行绘制，合成图层，显示在屏幕上 注意： 浏览器在生成网页的过程中，至少渲染一次 在用户浏览的过程中，还会不断重新渲染 （render &#x3D; n+1） 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且CSS也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM 缓存机制Service Worker&amp;emsp;&amp;emsp;Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。 注册Service Worker 监听到install事件以后就可以缓存需要的文件 在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存直接读取文件，否则就去请求数据。 Memory Cache&amp;emsp;&amp;emsp;内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。特点读取快，持续时间短，内容小导致存储数据小 Disk Cache&amp;emsp;&amp;emsp;存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 Push Cache&amp;emsp;&amp;emsp;Push Cache（推送缓存）是 HTTP&#x2F;2 中的内容，当以上三种缓存都没有命中时，它才会被使用。只在会话中存在，缓存时间短 跨域跨域问题的出现&amp;emsp;&amp;emsp;当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不一同，即跨域： 同源策略的限制 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 无法接触非同源网页的 DOM 无法向非同源地址发送 AJAX 请求 跨域解决方法 设置document.domain(此方案仅限主域相同，子域不同的跨域应用场景。) window.postMessage() JSONP（json with padding） CORS 是跨域资源分享 websocket Nginx反向代理 浏览器常见攻击方式XSS（跨站脚本攻击）&amp;emsp;&amp;emsp;XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。 CSRF(跨站请求伪造)&amp;emsp;&amp;emsp;CSRF 攻击就是利用了用户的登录状态，并通过第三方的站点来做一些坏事。而且CSRF 攻击并不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击 浏览器加载资源顺序 最高级：html、css、font js、xhr 图片、语音、视频 prefecth预加载的资源 浏览器输入url到页面展示出来的全过程 用户在浏览器中输入url地址 浏览器解析域名得到服务器ip地址 TCP三次握手建立客户端和服务器的连接 客户端发送HTTP请求获取服务器端的静态资源 服务器发送HTTP响应报文给客户端，客户端获取到页面静态资源 TCP四次挥手关闭客户端和服务器的连接 浏览器解析文档资源并渲染页面 渲染引擎什么情况下才会为特定的节点创建新的图层 拥有层叠上下文属性的元素会被提升为单独的一层。 需要剪裁（clip）的地方也会被创建为图层。 定时器与requestAnimationFrame、requestIdleCallbacksetTimeout&amp;emsp;&amp;emsp;执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责。但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间 1234setTimeout(() =&gt; &#123; console.log(1);&#125;, 0)console.log(2); // 2, 1 setInterval&amp;emsp;&amp;emsp;以指定周期调用函数，而setInterval则是每次都精确的隔一段时间推入一个事件（但是，事件的执行时间不一定就不准确，还有可能是这个事件还没执行完毕，下一个事件就来了）. requestAnimationFrame&amp;emsp;&amp;emsp;requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。 requestIdleCallback()&amp;emsp;&amp;emsp;requestIdleCallback则会在每次屏幕刷新时，判断当前帧是否还有多余的时间，如果有，则会调用requestAnimationFrame的回调函数","categories":[{"name":"面经","slug":"面经","permalink":"https://1518277259.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://1518277259.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"Vue和Rect的比较","slug":"Vue和React的比较","date":"2023-02-20T08:24:51.000Z","updated":"2023-03-02T12:38:45.626Z","comments":true,"path":"2023/02/20/Vue和React的比较/","link":"","permalink":"https://1518277259.github.io/2023/02/20/Vue%E5%92%8CReact%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"","text":"Vue和Rect的比较[toc] vue 和 react 在 虚拟dom的diff上，做了哪些改进使 速度更快？1、传统diff&amp;emsp;&amp;emsp;计算两颗树形结构差异并进行转换，传统diff算法是这样做的：循环递归每一个节点 。传统diff算法复杂度达到O(n^3 )这意味着1000个节点就要进行数10亿次的比较，这是非常消耗性能的。 2. vue的diff算法diff算法发生在虚拟dom上,判断是否同一个节点：selector和key都要一样 diff规则： 只比较同层的节点，不同层不做比较。删除原节点，并且新建插入更新节点（实际开发中很少遇到） 新旧节点是同层节点，但不是同一个节点，不做精细化比较。删除原节点，并且新建插入更新节点（实际开发中很少遇到） 新旧节点是同层节点，也是同一个节点，需要做精细化比较 3. react的diff算法&amp;emsp;&amp;emsp;从左往右依次对比，利用元素的index和标识lastIndex进行比较，如果满足index &lt; lastIndex就移动元素，删除和添加则各自按照规则调整,跨层不比较，同层比较，跟vue一样 diff策略: 不满足 index &lt; lastIndex 的条件，不移动；满足 index &lt; lastIndex 的条件，移动节点。 每一次比较都需要重新设置 lastIndex&#x3D;(index,lastIndex)中的较大数 移动的节点在前一个被操作的节点后面 如果从新的节点集合获取的节点在旧节点集合未找到，就是新增，lastIndex为上一次的值不变 如果新的节点集合遍历完了，旧节点还有值就是删除，loop删除掉就行 4. 对比相同点：&amp;emsp;&amp;emsp;Vue和react的diff算法，都是不进行跨层级比较，只做同级比较。 不同点： Vue进行diff时，调用patch打补丁函数，一边比较一边给真实的DOM打补丁 Vue对比节点，当节点元素类型相同，但是className不同时，认为是不同类型的元素，删除重新创建，而react则认为是同类型节点，进行修改操作 &amp;emsp;&amp;emsp;① Vue的列表比对，采用从两端到中间的方式，旧集合和新集合两端各存在两个指针，两两进行比较，如果匹配上了就按照新集合去调整旧集合，每次对比结束后，指针向队列中间移动；&amp;emsp;&amp;emsp;②而react则是从左往右依次对比，利用元素的index和标识lastIndex进行比较，如果满足index &lt; lastIndex就移动元素，删除和添加则各自按照规则调整；&amp;emsp;&amp;emsp;③当一个集合把最后一个节点移动到最前面，react会把前面的节点依次向后移动，而Vue只会把最后一个节点放在最前面，这样的操作来看，Vue的diff性能是高于react的 vue 和 react 里的key的作用是什么? 为什么不能用Index？用了会怎样? 如果不加key会怎样?1.什么是keykey是虚拟Dom对象的标识，在更新显示时key起着极其重要的作用。 2.key的作用当Vue中data或React中state的数据发生变化时，react会根据新数据生成新的虚拟Dom，随后Vue&#x2F;React会对「新虚拟Dom」和「旧虚拟Dom」进行diff比较，比较规则如下： 旧虚拟Dom中找到与新虚拟Dom相同的key： 若虚拟Dom中的内容没变，则直接使用之前的真实Dom 若虚拟Dom中的内容变了，则生成新的真实Dom，随后替换掉页面中之前的真实Dom 旧虚拟Dom中没有找到与新虚拟Dom相同的key： 根据数据创建新的真实Dom，随后渲染到页面 3.为什么遍历列表时，key最好不要用index用index作为key，可能引发的问题如下： 若对数据进行逆序添加，逆序删除等破坏顺序的操作，会产生虚拟DOM和旧的真实DOM中的部分key（甚至所有Key）都对不上的问题，接着会产生很多没有必要的真实DOM更新，渲染效率低下。 如果列表行结构中还包含输入类的DOM，则会产生错误的DOM更新，使得界面出现问题 如果只是数据单纯的展示，不做增删改，使用index也没关系 4.如果不加key会怎样? 当不带Key的时候，采用的是遍历的方式来对比新旧节点，从而达到更新节点的效果。 带key的时候使用的是map映射来更新节点。 在模板简单的时候使用就地复用（就是不使用key）效率会更高。 所以使用key并不意味着一定可以提高diff算法的效率。 key的作用主要是为每个节点设置一个唯一的标识，可以更快，更准确的拿到节点。 在一些情况下，还可以避免就地复用带来的副作用（表单数据错位）","categories":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/tags/vue/"}]},{"title":"Vue解析","slug":"Vue解析","date":"2023-02-20T00:24:51.000Z","updated":"2023-03-02T13:06:19.075Z","comments":true,"path":"2023/02/20/Vue解析/","link":"","permalink":"https://1518277259.github.io/2023/02/20/Vue%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Vue解析Vue响应式原理&amp;emsp;&amp;emsp;vue响应式也叫作数据双向绑定，大致原理阐述： 首先我们需要通过Object.defineProperty()方法把数据(data)设置为getter和setter的访问形式，这样我们就可以在数据被修改时在setter方法设置监视修改页面信息，也就是说每当数据被修改，就会触发对应的set方法，然后我们可以在set方法中去调用操作dom的方法。 &amp;emsp;&amp;emsp;vue实现数据响应式，是通过数据劫持侦测数据变化，发布订阅模式进行依赖收集与视图更新，换句话说是Observe，Watcher以及Compile三者相互配 Observe实现数据劫持，递归给对象属性，绑定setter和getter函数，属性改变时，通知订阅者 Compile解析模板，把模板中变量换成数据，绑定更新函数，添加订阅者，收到通知就执行更新函数 Watcher作为Observe和Compile中间的桥梁，订阅Observe属性变化的消息，触发Compile更新函数 发布订阅模式和观察者模式的区别观察者模式&amp;emsp;&amp;emsp;观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。 核心： 观察者(Watcher): 每个观察者必须有一个 update() 方法，当事件发生时，执行观察者的update()。观察者可以理解为发布&#x2F;订阅模式的订阅者。 目标(Dependency依赖)：可以理解为发布&#x2F;订阅模式的发布者 订阅发布模式&amp;emsp;&amp;emsp;现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。 核心： 订阅者 发布者 信号中心(事件中心) VDom&amp;emsp;&amp;emsp;VDom顾名思义就是虚拟的dom对象，它本身就是⼀个 JavaScript 对象，利用JS对象来表示真实DOM的树结构，创建一个虚拟的DOm对象 好处 将真实元素节点抽象成 VNode，有效减少直接操作 dom 次数，从而提高程序性能 方便实现跨平台 不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升； 可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。 无需手动操作DOM 缺点 无法进行极致优化，在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化 首次渲染大量DOM时，由于多了一层虚拟DOM计算，会比innerHTML插入慢 nextTick()&amp;emsp;&amp;emsp;Vue.nextTick用于延迟执行一段代码，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回promise对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 源码/** * Defer a task to execute it asynchronously. */export const nextTick = (function () &#123; const callbacks = [] let pending = false let timerFunc function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125; &#125; // the nextTick behavior leverages the microtask queue, which can be accessed // via either native Promise.then or MutationObserver. // MutationObserver has wider support, however it is seriously bugged in // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore if */ if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&#x27;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; &#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27; )) &#123; // use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; &#125; else &#123; // fallback to setTimeout /* istanbul ignore next */ timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) &#125; &#125; return function queueNextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve = resolve &#125;) &#125; &#125;&#125;)() 生命周期 beforeCreate：在实例被完成创建出来，el和data都没有初始化，不能访问data、method，一般在这个阶段不进行操作。 created：vue实例中的data、method已被初始化，属性也被绑定，但是此时还是虚拟dom，真是dom还没生成，$el 还不可用。 beforeMount：此时模板已经编译完成，但还没有被渲染至页面中（即为虚拟dom加载为真实dom），此时el存在则会显示el。 Mounted：此时模板已经被渲染成真实DOM，用户已经可以看到渲染完成的页面，页面的数据也是通过双向绑定显示data中的数据。 beforeUpdate：重新渲染之前触发，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。 updated：数据已经更改完成，dom也重新render完成。 beforeDestroy：销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等…’) destroyed：销毁后 （Dom元素存在，只是不再受vue控制）,卸载watcher，事件监听，子组件。 vue-router VueRouter ：路由器类，根据路由请求在路由视图中动态渲染选中的组件 router-link ：路由链接组件，声明用以提交路由请求的用户接口 router-view：路由视图组件，负责动态渲染路由选中的组件 路由传参动态路由匹配1234567891011121314151617// 路由const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 &#123; path: &#x27;/user/:id&#x27;, component: User &#125; ]&#125;)// 传递参数// 1. 声明式&lt;router-link :to=&quot;/user/1&quot;&gt; 跳转到匹配路由 &lt;/router-link&gt;// 2. 编程式this.$router.push(&#123; path: &#x27;/child/$&#123;id&#125;&#x27;,&#125;) Url传参方式 通过params显式传参 12345678910111213// 路由const routes = [&#123; path: &#x27;/child/:id&#x27;, name: &#x27;Child&#x27;, component: () =&gt; import(&#x27;@/components/Child&#x27;)&#125;]// 传递参数this.$router.push(&#123; path: &#x27;/child/foo&#x27;,&#125;)// 接受参数this.$route.params.id === foo 1234567891011121314// 还可以配置多个参数const routes = [&#123; path: &#x27;/user/:name/hobby/:id&#x27;, component: UserComponent&#125;]// 传递参数:这里 username 对应[:name]， userHobby 对应[:id]// 其它字段必须完全一致，否则无法匹配this.$router.push(&#123; path: &#x27;/user/userName/hobby/userHobby&#x27;&#125;)// 接收参数this.$route.params.name === userNamethis.$route.params.id === userHobby 通过params隐式传参 123456789101112131415// 路由const routes = [&#123; path: &#x27;/child&#x27;, name: &#x27;Child&#x27;, component: () =&gt; import(&#x27;@/components/Child&#x27;)&#125;]// 传递参数this.$router.push(&#123; name: &#x27;Child&#x27;, params: &#123; id: 1 &#125;&#125;)// 接收参数this.$route.params.id === 1 通过query传递参数 123456789101112131415// 路由const routes = [&#123; path: &#x27;/child&#x27;, name: &#x27;Child&#x27;, component: () =&gt; import(&#x27;@/components/Child&#x27;)&#125;]// 传递参数（通过 name 或者 path 来匹配路由)this.$router.push(&#123; path: &#x27;/child&#x27;, query: &#123; id: 1 &#125;&#125;)// 接收参数this.$route.query.id === 1 完整的导航解析流程 导航被触发 在失活的组件里调用beforeRouteLeave 守卫 调用全局的beforeEnch守卫 在重用的组件中调用beforeRouteUpdate守卫 在路由组件配置中调用BeforEnter 解析异步路由组件 在激活的组件中调用beforeRouteEnter 调用全局的bbeforeResolve 导航被确认 调用全局的afterEach钩子 触发DOM更新 调用beforeRouteEnter守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入 vuex&amp;emsp;&amp;emsp;相当于一个公共仓库，保存着所有组件都能共用的数据 state:保存所有数据，以对象的方式导出 mutations:保存所有方法，用来改变state的数据 actions:暴露给用户使用，借此触发mutations中的方法，保存数据（可执行异步操作） gettings:获取数据 Vue3新特性 compositionAPI（组合式API），代码组织更方便了, 逻辑复用更方便了 非常利于维护! 检测类型 ( 类型推导 Typescript 支持 ) ES6 的 proxy 替代了 ES5 的 Object.defineProperty template 模板可以有多个根元素 compositionAPI setup 中不能使用 this, this 指向 undefined reactive函数：将复杂类型数据, 转换成响应式数据 ref 函数：对传入的数据（一般简单数据类型），包裹一层对象, 转换成响应式。 toRef 函数：使用 toRef函数 , 将 reactive 函数的响应式对象中的指定属性转换为响应式数据 toRefs 函数：对一个 响应式对象 的所有内部属性, 都做响应式处理, 保证展开或者解构出的数据也是响应式的( 一般配合 reactive 使用) computed 函数：computed 函数调用时, 要接收一个处理函数, 处理函数中, 需要返回计算属性的值 keep-alive&amp;emsp;&amp;emsp;keep-alive是用来缓存组件的，提供了两个activated与deactivated。 include - 逗号分隔字符串或正则表达式或一个数组来表示。只有名称匹配的组件会被缓存。 exclude - 逗号分隔字符串或正则表达式或一个数组来表示。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 源码export default &#123; name: &#x27;keep-alive&#x27;, abstract: true, props: &#123; include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] &#125;, created () &#123; this.cache = Object.create(null) this.keys = [] &#125;, destroyed () &#123; for (const key in this.cache) &#123; pruneCacheEntry(this.cache, key, this.keys) &#125; &#125;, mounted () &#123; this.$watch(&#x27;include&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; matches(val, name)) &#125;) this.$watch(&#x27;exclude&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; !matches(val, name)) &#125;) &#125;, render() &#123; /* 获取默认插槽中的第一个组件节点 */ const slot = this.$slots.default const vnode = getFirstComponentChild(slot) /* 获取该组件节点的componentOptions */ const componentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) &#123; /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */ const name = getComponentName(componentOptions) const &#123; include, exclude &#125; = this /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */ if ( (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; return vnode &#125; const &#123; cache, keys &#125; = this const key = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;) : vnode.key if (cache[key]) &#123; vnode.componentInstance = cache[key].componentInstance // make current key freshest remove(keys, key) keys.push(key) &#125; else &#123; cache[key] = vnode keys.push(key) // prune oldest entry if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; pruneCacheEntry(cache, keys[0], keys, this._vnode) &#125; &#125; vnode.data.keepAlive = true &#125; return vnode || (slot &amp;&amp; slot[0]) &#125;&#125; 为什么访问data属性不需要带data&amp;emsp;&amp;emsp;vue中访问属性代理 this.data.xxx 转换 this.xxx 的实现 template预编译&amp;emsp;&amp;emsp;当vue进行打包时，会直接把组件中的模板转换为render函数，这叫做模板预编译 好处： 运行时就不再需要编译模板了，提高了运行效率，打包结果中不再需要vue的编译代码，减少了打包体积 diff算法&amp;emsp;&amp;emsp;diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。 特点： 同级比较，循环从两边向中间比较 v-if 和v-showv-showv-show严格意义来说其实是条件隐藏，直接在页面初始化的时候将DOM(对象模型)元素也初始化，因为它就是将它所在的元素添加一个display属性为none，如果条件符合就显示。 v-ifv-if严格意义来说就是条件判断，符合就加载DOM(对象模型)元素，不符合就不显示。 区别 v-if有更高的切换性能，比如说需要判断多个条件时，就使用if。 如果需要频繁的切换，选择v-show，因为show是动态的改变样式，不需要增删DOM(对象模型)元素，大项目推荐使用show，能极大减少浏览器后期的操作性能。 v-for和v-if的优先级 在vue2中，v-for的优先级是高于v-if，如果把它们放在一起，每次循环都会遍历整个列表，造成资源浪费。 在vue3中v-if的优先级高于v-for，会报错","categories":[{"name":"面经","slug":"面经","permalink":"https://1518277259.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/tags/vue/"}]},{"title":"设计模式","slug":"设计模式","date":"2023-02-19T02:24:51.000Z","updated":"2023-03-02T12:33:57.006Z","comments":true,"path":"2023/02/19/设计模式/","link":"","permalink":"https://1518277259.github.io/2023/02/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式创建型模式原型模式是用于创建重复的对象，同时又能保证性能。 123456789101112function Person () &#123; Person.prototype.name = &quot;marry&quot;; Person.prototype.sayName = function()&#123; console.log(this.name); &#125;&#125; const person1 = new Person();const person2 = new Person();person1.sayName(); // marryperson2.sayName(); // marryconsole.log(person1.sayName === person2.sayName); // true 单例模式单例模式（Singleton Pattern）涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。 特点： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 1234567891011121314151617// 单例模式let box;const createBox = (_a, _b) =&gt; &#123; if(!box)&#123; box = &#123;&#125;; &#125; box.a = _a; box.b = _b; return box;&#125;; const obj1 = createBox(3, 6);obj1; // &#123;a: 3, b: 6&#125; const obj2 = createBox(10, 20);obj1; // &#123;a: 10, b: 20&#125;obj2; // &#123;a: 10, b: 20&#125; 工厂模式根据不同的输入返回不同类的实例，一般用来创建同一类对象 优点： 良好的封装，代码结构清晰，访问者无需知道对象的创建流程，特别是创建比较复杂的情况下； 扩展性优良，通过工厂方法隔离了用户和创建流程隔离，符合开放封闭原则； 解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流； 缺点：&amp;emsp;&amp;emsp;带来了额外的系统复杂度，增加了抽象性； 123456789101112131415161718192021222324252627282930313233343536373839// 饭店方法 class Restaurant &#123; static getMenu(menu) &#123; switch (menu) &#123; case &#x27;鱼香肉丝&#x27;: return new YuXiangRouSi(); case &#x27;宫保鸡丁&#x27;: return new GongBaoJiDin(); default: throw new Error(&#x27;这个菜本店没有&#x27;); &#125; &#125;&#125;; // 鱼香肉丝类 class YuXiangRouSi &#123; constructor() &#123; this.type = &#x27;鱼香肉丝&#x27; &#125; eat() &#123; console.log(this.type + &#x27; 真香&#x27;) &#125;&#125;; // 宫保鸡丁类class GongBaoJiDin &#123; constructor() &#123; this.type = &#x27;宫保鸡丁&#x27; &#125; eat() &#123; console.log(this.type + &#x27; 让我想起了外婆做的菜&#x27;); &#125;&#125;; const dish1 = Restaurant.getMenu(&#x27;鱼香肉丝&#x27;);dish1.eat(); // 鱼香肉丝 真香const dish2 = Restaurant.getMenu(&#x27;红烧排骨&#x27;); // Error 这个菜本店没有 抽象工厂模式&amp;emsp;&amp;emsp;通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，从实例的具体实现中解耦。 优点：&amp;emsp;&amp;emsp;抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦； 缺点： 扩展新类簇的产品类比较困难，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开放封闭原则； 带来了系统复杂度，增加了新的类，和新的继承关系； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 饭店 抽象类，饭店都可以做菜和汤class AbstractRestaurant &#123; constructor() &#123; if (new.target === AbstractRestaurant) &#123; throw new Error(&#x27;抽象类不能直接实例化!&#x27;) &#125; this.signborad = &#x27;饭店&#x27; &#125; // 抽象方法：创建菜 createDish() &#123; throw new Error(&#x27;抽象方法不能调用!&#x27;) &#125; // 抽象方法：创建汤 createSoup() &#123; throw new Error(&#x27;抽象方法不能调用!&#x27;) &#125;&#125; // 饭店 具体类 class Restaurant extends AbstractRestaurant &#123; constructor() &#123; super() &#125; createDish(type) &#123; switch (type) &#123; case &#x27;鱼香肉丝&#x27;: return new YuXiangRouSi(); case &#x27;宫保鸡丁&#x27;: return new GongBaoJiDing(); default: throw new Error(&#x27;本店没这个菜&#x27;); &#125; &#125; createSoup(type) &#123; switch (type) &#123; case &#x27;紫菜蛋汤&#x27;: return new ZiCaiDanTang(); default: throw new Error(&#x27;本店没这个汤&#x27;); &#125; &#125;&#125; // 菜 抽象类，菜都有吃的功能class AbstractDish &#123; constructor() &#123; if (new.target === AbstractDish) &#123; throw new Error(&#x27;抽象类不能直接实例化!&#x27;) &#125; this.kind = &#x27;菜&#x27; &#125; // 抽象方法 eat() &#123; throw new Error(&#x27;抽象方法不能调用!&#x27;) &#125;&#125; // 菜 鱼香肉丝类class YuXiangRouSi extends AbstractDish &#123; constructor() &#123; super() this.type = &#x27;鱼香肉丝&#x27; &#125; eat() &#123; console.log(this.kind + &#x27; - &#x27; + this.type + &#x27; 真香~&#x27;) &#125;&#125;// 菜 宫保鸡丁类class GongBaoJiDing extends AbstractDish &#123; constructor() &#123; super() this.type = &#x27;宫保鸡丁&#x27; &#125; eat() &#123; console.log(this.kind + &#x27; - &#x27; + this.type + &#x27; 让我想起了外婆做的菜&#x27;) &#125;&#125; // 汤 抽象类，汤都有喝的功能class AbstractSoup &#123; constructor() &#123; if (new.target === AbstractDish) &#123; throw new Error(&#x27;抽象类不能直接实例化!&#x27;) &#125; this.kind = &#x27;汤&#x27; &#125; // 抽象方法 drink() &#123; throw new Error(&#x27;抽象方法不能调用!&#x27;) &#125;&#125; // 汤 紫菜蛋汤类class ZiCaiDanTang extends AbstractSoup &#123; constructor() &#123; super() this.type = &#x27;紫菜蛋汤&#x27; &#125; drink() &#123; console.log(this.kind + &#x27; - &#x27; + this.type + &#x27; 我从小喝到大&#x27;) &#125;&#125; const restaurant = new Restaurant(); const soup1 = restaurant.createSoup(&#x27;紫菜蛋汤&#x27;);soup1.drink();// 汤 - 紫菜蛋汤 我从小喝到大const dish1 = restaurant.createDish(&#x27;鱼香肉丝&#x27;);dish1.eat();// 菜 - 鱼香肉丝 真香const dish2 = restaurant.createDish(&#x27;红烧排骨&#x27;);// Error 本店没有这个 建造者模式用于分步构建一个复杂的对象，将一个复杂对象的 构建层与其表示层分离。若不是极其复杂的对象，应选择使用对象字面或工厂模式等方式创建对象。 优点： 封装性好，创建和使用分离； 扩展性好，建造类之间独立、一定程度上解耦。 缺点: 产生多余的Builder对象； 产品内部发生变化，建造者都要修改，成本较大。 12345678910111213141516171819202122232425262728293031// 建造者，汽车部件厂家class CarBuilder &#123; constructor(param) &#123; this.param = param; &#125; // 生产部件，part1 buildPart1() &#123; this.part1 = &#x27;part1&#x27;; return this &#125; // 生产部件，part2 buildPart2() &#123; this.part2 = &#x27;part2&#x27;; return this; &#125;&#125; // 汽车装配，获得产品实例const benchi1 = new CarBuilder(&#x27;param&#x27;).buildPart1().buildPart2(); console.log(benchi1); // &#123;// param: &quot;param&quot;// part1: &quot;part1&quot;// part2: &quot;part2&quot;// &#125; 结构性模式桥架模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。 优点： 分离了抽象和实现部分，将实现层（DOM 元素事件触发并执行具体修改逻辑）和抽象层（ 元素外观、尺寸部分的修改函数）解耦，有利于分层； 提高了可扩展性，多个维度的部件自由组合，避免了类继承带来的强耦合关系，也减少了部件类的数量； 使用者不用关心细节的实现，可以方便快捷地进行使用； 缺点： 桥接模式要求两个部件没有耦合关系，否则无法独立地变化，因此要求正确的对系统变化的维度进行识别，使用范围存在局限性； 桥接模式的引入增加了系统复杂度； 12345678910111213141516171819202122232425262728293031323334353637383940function Boy(instrument) &#123; this.sayHi = function() &#123; console.log(&#x27;hi, 我是男生&#x27;) &#125; // 有一个功能叫playInstrument， 没有具体乐器 this.playInstrument = function() &#123; instrument.play() &#125;&#125; function Girl(instrument) &#123; this.sayHi = function() &#123; console.log(&#x27;hi, 我是女生&#x27;) &#125; // 有一个功能叫playInstrument， 没有具体乐器 this.playInstrument = function() &#123; instrument.play() &#125;&#125; function Piano() &#123; this.play = function() &#123; console.log(&#x27;钢琴开始演奏&#x27;) &#125;&#125; function Guitar() &#123; this.play = function() &#123; console.log(&#x27;吉他开始演奏&#x27;) &#125;&#125; let piano = new Piano()let guitar = new Guitar()let pianoBoy = new Boy(piano)pianoBoy.playInstrument()let guitarGirl = new Girl(guitar)guitarGirl.playInstrument() 外观模式外观模式为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。 优点： 访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的 使用变得简单 ，符合最少知识原则，增强了可移植性和可读性； 减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性； 通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性； 缺点： 不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口； 不需要或不合理的使用外观会让人迷惑，过犹不及； 1234567891011function setBox()&#123; var getId = document.getElementById(&#x27;isShow&#x27;); return &#123; show : function()&#123; getId.style.display = &#x27;block&#x27;; &#125;, hide : function()&#123; getId.style.display = &#x27;none&#x27;; &#125; &#125;&#125; 享元模式运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。通俗来讲，享元就是共享单元，比如现在流行的共享单车、共享充电宝等，他们的核心理念都是享元模式。 优点： 由于减少了系统中的对象数量，提高了程序运行效率和性能，精简了内存占用，加快运行速度； 外部状态相对独立，不会影响到内部状态，所以享元对象能够在不同的环境被共享； 缺点： 引入了共享对象，使对象结构变得复杂； 共享对象的创建、销毁等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899var Upload = function(uploadType) &#123; this.uploadType = uploadType;&#125;/* 删除文件（内部状态） */Upload.prototype.delFile = function(id) &#123; uploadManger.setExternalState(id, this); // 把当前id对应的外部状态都组装到共享对象中 // 大于3000k提示 if(this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if(window.confirm(&quot;确定要删除文件吗？&quot; + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;/** 工厂对象实例化 * 如果某种内部状态的共享对象已经被创建过，那么直接返回这个对象 * 否则，创建一个新的对象 */var UploadFactory = (function() &#123; var createdFlyWeightObjs = &#123;&#125;; return &#123; create: function(uploadType) &#123; if(createdFlyWeightObjs[uploadType]) &#123; return createdFlyWeightObjs[uploadType]; &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType); &#125; &#125;;&#125;)();/* 管理器封装外部状态 */var uploadManger = (function() &#123; var uploadDatabase = &#123;&#125;;​ return &#123; add: function(id, uploadType, fileName, fileSize) &#123; var flyWeightObj = UploadFactory.create(uploadType); var dom = document.createElement(&#x27;div&#x27;); dom.innerHTML = &quot;&lt;span&gt;文件名称：&quot; + fileName + &quot;，文件大小：&quot; + fileSize +&quot;&lt;/span&gt;&quot; + &quot;&lt;button class=&#x27;delFile&#x27;&gt;删除&lt;/button&gt;&quot;;​ dom.querySelector(&quot;.delFile&quot;).onclick = function() &#123; flyWeightObj.delFile(id); &#125;; document.body.appendChild(dom);​ uploadDatabase[id] = &#123; fileName: fileName, fileSize: fileSize, dom: dom &#125;;​ return flyWeightObj; &#125;, setExternalState: function(id, flyWeightObj) &#123; var uploadData = uploadDatabase[id]; for(var i in uploadData) &#123; // 直接改变形参（新思路！！） flyWeightObj[i] = uploadData[i]; &#125; &#125; &#125;;&#125;)();​/*触发上传动作*/var id = 0;window.startUpload = function(uploadType, files) &#123; for(var i=0,file; file = files[i++];) &#123; var uploadObj = uploadManger.add(++id, uploadType, file.fileName, file.fileSize); &#125;&#125;;​/* 测试 */startUpload(&quot;plugin&quot;, [ &#123; fileName: &#x27;1.txt&#x27;, fileSize: 1000 &#125;,&#123; fileName: &#x27;2.txt&#x27;, fileSize: 3000 &#125;,&#123; fileName: &#x27;3.txt&#x27;, fileSize: 5000 &#125;]);startUpload(&quot;flash&quot;, [ &#123; fileName: &#x27;4.txt&#x27;, fileSize: 1000 &#125;,&#123; fileName: &#x27;5.txt&#x27;, fileSize: 3000 &#125;,&#123; fileName: &#x27;6.txt&#x27;, fileSize: 5000 &#125;]); 适配器模式代理模式组合模式装饰器模式组合模式装饰器模式行为型模式观察者模式迭代器模式策略模式模板方法模式状态模式命令模式访问者模式","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"websocket解析","slug":"websocket解析","date":"2023-02-18T02:24:51.000Z","updated":"2023-03-02T12:29:07.011Z","comments":true,"path":"2023/02/18/websocket解析/","link":"","permalink":"https://1518277259.github.io/2023/02/18/websocket%E8%A7%A3%E6%9E%90/","excerpt":"","text":"websocket解析什么是websocket WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议） 它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的 Websocket是一个持久化的协议 websocket的原理 websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信 在websocket出现之前，web交互一般是基于http协议的短连接或者长连接 websocket是一种全新的协议，不属于http无状态协议，协议名为”ws” websocket与http的关系相同点： 都是基于tcp的，都是可靠性传输协议 都是应用层协议 不同点： WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息 HTTP是单向的 WebSocket是需要浏览器和服务器握手进行建立连接的 http是浏览器发起向服务器的连接，服务器预先并不知道这个连接 联系WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的 总结 首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等； 然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据； 最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。 JS websocket实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import Store from &quot;@/store&quot;;class WebSocketClass &#123; // 要连接的URL url; // 一个协议字符串或一个协议字符串数组。 // 这些字符串用来指定子协议，这样一个服务器就可以实现多个WebSocket子协议 protocols; // WebSocket 实例 ws; // 是否在重连中 isReconnectionLoading = false; // 延时重连的 id timeId = null; // 是否是用户手动关闭连接 isCustomClose = false; // 错误消息队列 errorStack = []; constructor(url, protocols) &#123; this.url = url; this.protocols = protocols; this.createWs(); &#125; createWs() &#123; if (&quot;WebSocket&quot; in window) &#123; // 实例化 this.ws = new WebSocket(this.url, this.protocols); // 监听事件 this.onopen(); this.onerror(); this.onclose(); this.onmessage(); &#125; else &#123; console.log(&quot;你的浏览器不支持 WebSocket&quot;); &#125; &#125; // 监听成功 onopen() &#123; this.ws.onopen = () =&gt; &#123; console.log(&quot;onopen&quot;); // 发送成功连接之前所发送失败的消息 this.errorStack.forEach((message) =&gt; &#123; this.send(message); &#125;); this.errorStack = []; this.isReconnectionLoading = false; &#125;; &#125; // 监听错误 onerror() &#123; this.ws.onerror = (err) =&gt; &#123; console.log(err, &quot;onerror&quot;); this.reconnection(); this.isReconnectionLoading = false; &#125;; &#125; // 监听关闭 onclose() &#123; this.ws.onclose = () =&gt; &#123; console.log(&quot;onclose&quot;); // 用户手动关闭的不重连 if (this.isCustomClose) return; this.reconnection(); this.isReconnectionLoading = false; &#125;; &#125; // 接收 WebSocket 消息 onmessage() &#123; this.ws.onmessage = (event) =&gt; &#123; try &#123; Store.dispatch(&quot;user/setData&quot;, event.data); &#125; catch (error) &#123; console.log(error, &quot;error&quot;); &#125; &#125;; &#125; // 是否连接中 isConnection() &#123; if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) return true else return false &#125; // 重连 reconnection() &#123; // 防止重复 if (this.isReconnectionLoading) return; this.isReconnectionLoading = true; clearTimeout(this.timeId); this.timeId = setTimeout(() =&gt; &#123; this.createWs(); &#125;, 100); &#125; // 发送消息 send(message) &#123; // 连接失败时的处理 if (this.ws.readyState !== 1) &#123; this.errorStack.push(message); return; &#125; this.ws.send(message); &#125; // 手动关闭 close() &#123; this.isCustomClose = true; this.ws.close(); &#125; // 手动开启 start() &#123; this.isCustomClose = false; this.reconnection(); &#125; // 销毁 destroy() &#123; this.close(); this.ws = null; this.errorStack = null; &#125;&#125;export default WebSocketClass;","categories":[{"name":"websocket","slug":"websocket","permalink":"https://1518277259.github.io/categories/websocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://1518277259.github.io/tags/websocket/"}]},{"title":"webpack解析","slug":"webpack解析","date":"2023-02-17T02:24:51.000Z","updated":"2023-03-02T12:15:57.942Z","comments":true,"path":"2023/02/17/webpack解析/","link":"","permalink":"https://1518277259.github.io/2023/02/17/webpack%E8%A7%A3%E6%9E%90/","excerpt":"","text":"webpack解析webpack的理解webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。我们可以使用webpack管理模块。因为在webpack看来，项目中的所有资源皆为模块，通过分析模块间的依赖关系，在其内部构建出一个依赖图，最终编绎输出模块为 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等），让我们的开发过程更加高效。 主要作用 模块打包：可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。 编译兼容：在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less，.vue，.jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。 能力扩展:通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。 webpack的构建流程 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过上一步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 常见的loader image-loader：加载并且压缩图片文件。 less-loader： 加载并编译 LESS 文件。 sass-loader：加载并编译 SASS&#x2F;SCSS 文件。 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性，使用css-loader必须要配合使用style-loader。 style-loader：用于将 CSS 编译完成的样式，挂载到页面的 style 标签上。需要注意 loader 执行顺序，style-loader 要放在第一位，loader 都是从后往前执行。 babel-loader：把 ES6 转换成 ES5 postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀。 eslint-loader：通过 ESLint 检查 JavaScript 代码。 vue-loader：加载并编译 Vue 组件。 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体) url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体) 常见的plugin有哪些？ HtmlWebpackPlugin：简化 HTML 文件创建 (依赖于 html-loader) mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin) clean-webpack-plugin: 目录清理 loader和plugin的区别？&amp;emsp;&amp;emsp;loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中；&amp;emsp;&amp;emsp;plugin赋予了webpack各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader无法实现的其他事。&amp;emsp;&amp;emsp;在运行时机上，loader 运行在打包文件之前；plugin则是在整个编译周期都起作用。&amp;emsp;&amp;emsp;在配置上，loader在module.rules中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性；plugin在 plugins中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。 webpack的热更新原理是？&amp;emsp;&amp;emsp;模块热替换(HMR - hot module replacement)，又叫做热更新，在不需要刷新整个页面的同时更新模块，能够提升开发的效率和体验。热更新时只会局部刷新页面上发生了变化的模块，同时可以保留当前页面的状态，比如复选框的选中状态等。&amp;emsp;&amp;emsp;热更新的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上webpack-dev-server与浏览器之间维护了一个websocket，当本地资源发生变化时，webpack-dev-server会向浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比。客户端对比出差异后会向webpack-dev-server发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向webpack-dev-server发起 jsonp 请求获取该chunk的增量更新。&amp;emsp;&amp;emsp;后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader和vue-loader都是借助这些 API 实现热更新。 如何提高webpack的构建速度？ 代码压缩 JS压缩：&amp;emsp;&amp;emsp;webpack 4.0默认在生产环境的时候是支持代码压缩的，即mode&#x3D;production模式下。实际上webpack 4.0默认是使用terser-webpack-plugin这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel参数，使用多进程压缩，加快压缩。 CSS压缩&amp;emsp;&amp;emsp;CSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件：css-minimizer-webpack-plugin。 HTML压缩&amp;emsp;&amp;emsp;使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。 图片压缩:配置image-webpack-loader Tree Shaking: 缩小打包域:&amp;emsp;&amp;emsp;排除webpack不需要解析的模块，即在使用loader的时候，在尽量少的模块中去使用。可以借助 include和exclude这两个参数，规定loader只在那些模块应用和在哪些模块不应用。","categories":[{"name":"webpack","slug":"webpack","permalink":"https://1518277259.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://1518277259.github.io/tags/webpack/"}]},{"title":"模块化方案","slug":"模块化方案","date":"2023-02-16T01:34:55.000Z","updated":"2023-03-02T12:11:45.094Z","comments":true,"path":"2023/02/16/模块化方案/","link":"","permalink":"https://1518277259.github.io/2023/02/16/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88/","excerpt":"","text":"模块化方案模块化优点 可维护性：每个模块都是单独定义的，之间相互独立 命名空间：为了避免在JavaScript中的全局污染，我们通过模块化的方式利用函数作用域来构建命名空间 可复用 模块化方案揭示模块模式(Reveaing Module)123456789101112131415161718192021var myRevealingModule = (function () &#123; var privateVar = “Ben Cherry”, publicVar = “Hey there!”; function privateFunction() &#123; console.log( &quot;Name:&quot; + privateVar ); &#125; function publicSetName( strName ) &#123; privateVar = strName; &#125; function publicGetName() &#123; privateFunction(); &#125; return &#123; setName: publicSetName, greeting: publicVar, getName: publicGetName &#125;;&#125;)();myRevealingModule.setName( “Paul Kinlan” ); 优点: 可以在任何地方实现（没有库，不需要语言支持）。 可以在单个文件中定义多个模块。 缺点: 无法以编程方式导入模块（除非使用eval）。 需要手动处理依赖关系。 无法异步加载模块。4。 循环依赖可能很麻烦。 很难通过静态代码分析器进行分析。 CommonJSCommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作(require 和 exports) 优点: 简单：开发人员可以在不查看文档的情况下掌握概念。 集成了依赖管理：模块需要其他模块并按所需顺序加载。 require可以在任何地方调用：模块可以通过编程方式加载。 缺点: 同步API使其不适合某些用途（客户端）。 每个模块一个文件。 浏览器需要加载程序库或转换。 模块没有构造函数（Node支持）。 很难进行静态代码分析。 ##### AMD AMD规范则是异步加载模块，允许指定回调函数，通过返回一个对象做为模块对象 优点: 异步加载（更好的启动时间）。 支持循环依赖。 require和的兼容性exports。 完全整合了依赖管理。 如有必要，可以将模块拆分为多个文件。 支持构造函数。 插件支持（自定义加载步骤）。 缺点: 语法稍微复杂一些。 除非编译，否则需要加载程序库。 很难分析静态代码。 除了异步加载以外，AMD的另一个优点是你可以在模块里使用对象、函数、构造函数、字符串、JSON或者别的数据类型，而CommonJS只支持对象。UMD 统一模块定义（UMD：Universal Module Definition ）就是将 AMD 和 CommonJS合在一起的一种尝试，常见的做法是将CommonJS 语法包裹在兼容 AMD 的代码中。 ES6模块支持JavaScript标准化的ECMA团队决定解决模块问题，兼容同步和异步操作模式。","categories":[{"name":"模块","slug":"模块","permalink":"https://1518277259.github.io/categories/%E6%A8%A1%E5%9D%97/"}],"tags":[{"name":"模块","slug":"模块","permalink":"https://1518277259.github.io/tags/%E6%A8%A1%E5%9D%97/"}]},{"title":"Less解析","slug":"Less解析","date":"2022-11-21T08:24:51.000Z","updated":"2023-03-02T13:21:08.965Z","comments":true,"path":"2022/11/21/Less解析/","link":"","permalink":"https://1518277259.github.io/2022/11/21/Less%E8%A7%A3%E6%9E%90/","excerpt":"","text":"less解析变量值变量以 @ 开头 定义变量，并且使用时 直接 键入 @名称。 12345678910111213141516@color: #999;@bgColor: skyblue;//不要添加引号@width: 50%;#wrap &#123; color: @color; background: @bgColor; width: @width;&#125;/* 生成后的 CSS */#wrap &#123; color: #999; background: skyblue; width: 50%;&#125; 选择器变量1234567891011121314151617181920212223242526/* Less */@mySelector: #wrap;@Wrap: wrap;@&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹 color: #999; width: 50%;&#125;.@&#123;Wrap&#125;&#123; color:#ccc;&#125;#@&#123;Wrap&#125;&#123; color:#666;&#125;/* 生成的 CSS */#wrap&#123; color: #999; width: 50%;&#125;.wrap&#123; color:#ccc;&#125;#wrap&#123; color:#666;&#125; 属性变量1234567891011/* Less */@borderStyle: border-style;@Soild:solid;#wrap&#123; @&#123;borderStyle&#125;: @Soild;//变量名 必须使用大括号包裹&#125;/* 生成的 CSS */#wrap&#123; border-style:solid;&#125; url变量12345678910/* Less */@images: &quot;../img&quot;;//需要加引号body &#123; background: url(&quot;@&#123;images&#125;/dog.png&quot;);//变量名 必须使用大括号包裹&#125;/* 生成的 CSS */body &#123; background: url(&quot;../img/dog.png&quot;);&#125; 声明方法1234567891011121314151617181920212223/* Less */@background: &#123;background:red;&#125;;#main&#123; @background();&#125;@Rules:&#123; width: 200px; height: 200px; border: solid 1px red;&#125;;#con&#123; @Rules();&#125;/* 生成的 CSS */#main&#123; background:red;&#125;#con&#123; width: 200px; height: 200px; border: solid 1px red;&#125; 变量运算12345678910111213141516171819/* Less */@width:300px;@color:#222;#wrap&#123; width:@width-20; height:@width-20*5; margin:(@width-20)*5; color:@color*2; background-color:@color + #111;&#125;/* 生成的 CSS */#wrap&#123; width:280px; height:200px; margin:1400px; color:#444; background-color:#333;&#125; 变量作用域123456789101112/* Less */@var: @a;@a: 100%;#wrap &#123; width: @var; @a: 9%;&#125;/* 生成的 CSS */#wrap &#123; width: 9%;&#125; 用变量去定义变量12345678910/* Less */@fnord: &quot;I am fnord.&quot;;@var: &quot;fnord&quot;;#wrap::after&#123; content: @@var; //将@var替换为其值 content:@fnord;&#125;/* 生成的 CSS */#wrap::after&#123; content: &quot;I am fnord.&quot;;&#125; 嵌套&amp;的用法12345678910111213141516171819202122/* Less */#header&#123; &amp;:after&#123; content:&quot;Less is more!&quot;; &#125; .title&#123; font-weight:bold; &#125; &amp;_content&#123;//理解方式：直接把 &amp; 替换成 #header margin:20px; &#125;&#125;/* 生成的 CSS */#header::after&#123; content:&quot;Less is more!&quot;;&#125;#header .title&#123; //嵌套了 font-weight:bold;&#125;#header_content&#123;//没有嵌套！ margin:20px;&#125; 媒体查询12345678910111213141516171819202122232425/* Less */#main&#123; //something... @media screen&#123; @media (max-width:768px)&#123; width:100px; &#125; &#125; @media tv &#123; width:2000px; &#125;&#125;/* 生成的 CSS */@media screen and (maxwidth:768px)&#123; #main&#123; width:100px; &#125;&#125;@media tv&#123; #main&#123; width:2000px; &#125;&#125; 混合方法无参数方法123456.card()&#123; //something...&#125;#wrap&#123; .card();&#125; . 与 # 皆可作为 方法前缀。 方法后写不写 () 看个人习惯。 默认参数方法 Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。 @arguments 犹如 JS 中的 arguments 指代的是 全部参数。 传的参数中 必须带着单位。 1234567891011121314151617181920212223242526272829/* Less */.border(@a:10px,@b:50px,@c:30px,@color:#000)&#123; border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数&#125;#main&#123; .border(0px,5px,30px,red);//必须带着单位&#125;#wrap&#123; .border(0px);&#125;#content&#123; .border;//等价于 .border()&#125;/* 生成的 CSS */#main&#123; border:solid 1px red; box-shadow:0px,5px,30px,red;&#125;#wrap&#123; border:solid 1px #000; box-shadow: 0px 50px 30px #000;&#125;#content&#123; border:solid 1px #000; box-shadow: 10px 50px 30px #000;&#125; 方法的匹配模式 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量，则将会匹配，如 @_ 。 123456789101112131415161718192021222324252627/* Less */.triangle(top,@width:20px,@color:#000)&#123; border-color:transparent transparent @color transparent ;&#125;.triangle(right,@width:20px,@color:#000)&#123; border-color:transparent @color transparent transparent ;&#125;.triangle(bottom,@width:20px,@color:#000)&#123; border-color:@color transparent transparent transparent ;&#125;.triangle(left,@width:20px,@color:#000)&#123; border-color:transparent transparent transparent @color;&#125;.triangle(@_,@width:20px,@color:#000)&#123; border-style: solid; border-width: @width;&#125;#main&#123; .triangle(left, 50px, #999)&#125;/* 生成的 CSS */#main&#123; border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px;&#125; 方法的命名空间 在 CSS 中&gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 12345678910111213141516171819202122232425262728293031323334/* Less */#card()&#123; background: #723232; .d(@w:300px)&#123; width: @w; #a(@h:300px)&#123; height: @h;//可以使用上一层传进来的方法 &#125; &#125;&#125;#wrap&#123; #card &gt; .d &gt; #a(100px); // 父元素不能加 括号&#125;#main&#123; #card .d();&#125;#con&#123; //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card&#125;/* 生成的 CSS */#wrap&#123; height:100px;&#125;#main&#123; width:300px;&#125;#con&#123; width:20px;&#125; 方法的条件筛选 比较运算有： &gt; &gt;&#x3D; &#x3D; &#x3D;&lt; &lt;。 &#x3D; 代表的是等于 除去关键字 true 以外的值都被视为 false： 1234567891011121314151617181920212223242526272829/* Less */#card&#123; // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行 .border(@width,@color,@style) when (@width&gt;100px) and(@color=#999)&#123; border:@style @color @width; &#125; // not 运算符，相当于 非运算 !，条件为 不符合才会执行 .background(@color) when not (@color&gt;=#222)&#123; background:@color; &#125; // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行 .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px)&#123; font-size: @size; &#125;&#125;#main&#123; #card&gt;.border(200px,#999,solid); #card .background(#111); #card &gt; .font(40px);&#125;/* 生成后的 CSS */#main&#123; border:solid #999 200px; background:#111; font-size:40px;&#125; 数量不定的参数1234567891011121314151617/* Less */.boxShadow(...)&#123; box-shadow: @arguments;&#125;.textShadow(@a,...)&#123; text-shadow: @arguments;&#125;#main&#123; .boxShadow(1px,4px,30px,red); .textShadow(1px,4px,30px,red);&#125;/* 生成后的 CSS */#main&#123; box-shadow: 1px 4px 30px red; text-shadow: 1px 4px 30px red;&#125; 方法使用的important！12345678910111213/* Less */.border&#123; border: solid 1px red; margin: 50px;&#125;#main&#123; .border() !important;&#125;/* 生成后的 CSS */#main &#123; border: solid 1px red !important; margin: 50px !important;&#125; 循环方法12345678910111213141516171819202122/* Less */.generate-columns(4);.generate-columns(@n, @i: 1) when (@i =&lt; @n) &#123; .column-@&#123;i&#125; &#123; width: (@i * 100% / @n); &#125; .generate-columns(@n, (@i + 1));&#125;/* 生成后的 CSS */.column-1 &#123; width: 25%;&#125;.column-2 &#123; width: 50%;&#125;.column-3 &#123; width: 75%;&#125;.column-4 &#123; width: 100%;&#125; 属性拼接方法+_ 代表的是 空格；+ 代表的是 逗号。 123456789101112/* Less */.boxShadow() &#123; box-shadow+: inset 0 0 10px #555;&#125;.main &#123; .boxShadow(); box-shadow+: 0 0 20px black;&#125;/* 生成后的 CSS */.main &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black;&#125; 12345678910111213/* Less */.Animation() &#123; transform+_: scale(2);&#125;.main &#123; .Animation(); transform+_: rotate(15deg);&#125;/* 生成的 CSS */.main &#123; transform: scale(2) rotate(15deg);&#125; 继承extend 关键字使用123456789101112131415161718192021/* Less */.animation&#123; transition: all .3s ease-out; .hide&#123; transform:scale(0); &#125;&#125;#main&#123; &amp;:extend(.animation);&#125;#con&#123; &amp;:extend(.animation .hide);&#125;/* 生成后的 CSS */.animation,#main&#123; transition: all .3s ease-out;&#125;.animation .hide , #con&#123; transform:scale(0);&#125; all 全局搜索替换123456789101112131415161718/* Less */#main&#123; width: 200px;&#125;#main &#123; &amp;:after &#123; content:&quot;Less is good!&quot;; &#125;&#125;#wrap:extend(#main all) &#123;&#125;/* 生成的 CSS */#main,#wrap&#123; width: 200px;&#125;#main:after, #wrap:after &#123; content: &quot;Less is good!&quot;;&#125; 减少代码的重复性 选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre). 可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr) - 注意这与 pre:hover:extend(div pre, .bucket tr)一样。 这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。 如果一个规则集包含多个选择器，所有选择器都可以使用extend关键字。 导入 导入 less 文件 可省略后缀 @import 的位置可随意放置 使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用。 @import语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。 使用@import (multiple)允许导入多个同名文件。 函数判断类型 isnumber： 判断给定的值 是否 是一个数字。 iscolor： 判断给定的值 是否 是一个颜色 isurl：判断给定的值 是否 是一个 url 。 颜色操作 saturate：增加一定数值的颜色饱和度。 lighten：增加一定数值的颜色亮度。 darken：降低一定数值的颜色亮度。 fade：给颜色设定一定数值的透明度。 mix：根据比例混合两种颜色。 数学函数 ceil：向上取整。 floor：向下取整。 percentage： 将浮点数转换为百分比字符串。 round：四舍五入 sqrt：计算一个数的平方根。 abs：计算数字的绝对值，原样保持单位 pow：计算一个数的乘方。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"JS解析","slug":"JS解析","date":"2022-10-03T08:24:51.000Z","updated":"2023-03-02T13:06:46.133Z","comments":true,"path":"2022/10/03/JS解析/","link":"","permalink":"https://1518277259.github.io/2022/10/03/JS%E8%A7%A3%E6%9E%90/","excerpt":"","text":"JS解析数据类型基本数据类型string 、number、 boolean、null、undefine、symbol、bigInt 引用数据类型function、array、RegExp、Date、Math this指向(一)普通函数的调用，this指向的是Window 1234567var name = &#x27;卡卡&#x27;;function cat()&#123; var name = &#x27;有鱼&#x27;; console.log(this.name);&#125;cat(); //卡卡 (二)对象的方法，this指的是该对象 一层作用域时，this指的是该对象 123456789var name = &#x27;卡卡&#x27;;var cat = &#123; name:&#x27;有鱼&#x27;, eat:function()&#123; console.log(this.name); &#125;&#125;cat.eat();//有鱼 多层作用域时，this指的是距离方法最近的一层对象 123456789101112131415var name = &#x27;卡卡&#x27;;var cat = &#123; name:&#x27;有鱼&#x27;, eat1:&#123; name:&#x27;年年&#x27;, eat2:function()&#123; console.log(this.name); &#125; &#125;&#125;cat.eat1.eat2();//年年var eat3 = cat.eat1.eat2;eat3(); // 卡卡 (三)构造函数的调用，this指的是实例化的新对象 123456789var name = &#x27;卡卡&#x27;;function Cat()&#123; this.name = &#x27;有鱼&#x27;; this.type = &#x27;英短蓝猫&#x27;;&#125;var cat1 = new Cat();console.log(cat1);// 实例化新对象 Cat &#123;name: &quot;有鱼&quot;, type: &quot;英短蓝猫&quot;&#125;console.log(cat1.name);// 有鱼 （四）apply和call调用时，this指向参数中的对象 1234567891011121314var name = &#x27;有鱼&#x27;;function eat()&#123; console.log(this.name);&#125;var cat = &#123; name:&#x27;年年&#x27;,&#125;var dog = &#123; name:&#x27;高飞&#x27;,&#125;eat.call(cat);// 年年eat.call(dog);// 高飞 （五）匿名函数调用，指向的是全局对象 12345678var name = &#x27;卡卡&#x27;;var cat = &#123; name:&#x27;有鱼&#x27;, eat:(function()&#123; console.log(this.name); &#125;)()&#125;cat.eat; //卡卡 （六）定时器中调用，指向的是全局变量 1234567var name = &#x27;卡卡&#x27;;var cat = setInterval(function()&#123; var name = &#x27;有鱼&#x27;; console.log(this.name);// 卡卡 clearInterval(cat);&#125;,500); （七）箭头函数调用 &amp;emsp;&amp;nbsp;如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this的值则被设置为全局对象 1234567891011121314151617var name = &#x27;window&#x27;;var student = &#123; name: &#x27;若川&#x27;, doSth: function()&#123; // var self = this; var arrowDoSth = () =&gt; &#123; // console.log(self.name); console.log(this.name); &#125; arrowDoSth(); &#125;, arrowDoSth2: () =&gt; &#123; console.log(this.name); &#125;&#125;student.doSth(); // &#x27;若川&#x27;student.arrowDoSth2(); // &#x27;window&#x27; 注意 ①普通函数的调用，this指向的是window ②对象方法的调用，this指的是该对象，且是最近的对象③构造函数的调用，this指的是实例化的新对象④apply和call调用，this指向参数中的对象⑤匿名函数的调用，this指向的是全局对象window⑥定时器中的调用，this指向的是全局变量window⑦.箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this的值则被设置为全局对象⑧.onclick和addEventerListener是指向绑定事件的元素（ev.currentTarget） call、apply、bind的原理及实现call&amp;emsp;&amp;nbsp;改变当前函数this指向，并立即执行 1234567Function.prototype.mycall = function(context,...args)&#123; context = (context == null || context == undefine)?window:new Object(context) context.fn = this context.fn = (...args) delete context.fn &#125; apply&amp;emsp;&amp;nbsp;将函数中的this指向传入的第一个参数，第二个为数组,和call方法作用相同，参数不同，立即执行 12345678Function.prototype.myapply = function(context,args)&#123; context = (context == null|| context == undefine)?window:new Object(context) context.fn = this if(!args) return context.fn let r = eval(&#x27;context.fn(&#x27;+args+&#x27;)&#x27;) delete context.fn return r&#125; bind&amp;emsp;&amp;nbsp;bind() 方法创建一个新的函数，不自动执行，需要手动调用bind() 。这个新函数的 this 被指定为 bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 1234567891011Function.prototype.mybind = function(context,...args1)&#123; let that = this function fbind(...args2)&#123; return that.call(this.instanceof fbind? this :context,...args1,...args2) &#125; function Fn()&#123; Fn.prototype = this.prototype fbind.prototype = new Fn() return fbind &#125;&#125; 变量提升&amp;emsp;&amp;nbsp;变量提升是指在js代码执行过程中，js引擎把变量的声明部分和函数声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值undefined&amp;emsp;&amp;nbsp;js在编译阶段的时候，会搜集所有的变量声明并且提前声明变量，而其他的语句都不会改变他们的顺序，因此，在编译阶段的时候，第一步就已经执行了，而第二步则是在执行阶段执行到该语句的时候才执行。 执行上下文&amp;emsp;&amp;emsp;执行上下文是js代码执行的一个环境，存放了代码执行所需的变量，变量查找的作用域链规则以及this指向等。在编译阶段创建 全局执行上下文：当进入全局代码时会进行编译，在编译中创建全局执行上下文，并生成可执行代码 函数执行上下文：执行代码的过程中，如果遇到函数调用，会编译函数内的代码和创建函数执行上下文，并创建可执行代码 eval执行上下文：：当使用eval函数的时候，eval的代码也会被编译，并创建执行上下文 作用域 全局作用域：不在函数内部作用域和块级内部作用域外的作用域 函数作用域：在函数内部的作用域 块级作用域：在花括号{}内部的作用域 注意： &amp;emsp;&amp;emsp;①对象的{}不属于块级作用域，像for(){},if(){},else{}，try{},cath(){}等等的花括号才是块级作用域&amp;emsp;&amp;emsp;②对象的{}的作用域是什么作用域取决于对象所处的作用域，比如对象在全局作域 下定义的，那么对象的{}的作用域就是全局作用域 作用域链&amp;emsp;&amp;emsp;内部作用域访问外部作用域的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链,采取就近原则的方式向上一级一级的作用域来查找变量值，最顶级是全局作用域，如果到全局作用域也没找值，那么就会报错。 闭包概念&amp;emsp;&amp;emsp;如果一个函数访问了此函数的父级及父级以上的作用域变量，那么这个函数就是一个闭包。即函数不在当前语法作用域中执行，而是在当前语法作用域外执行，但仍然保持对当前语法作用域的引用，这种引用叫闭包 特点 被闭包函数访问的父级及以上的函数的局部变量（如范例中的局部变量 i ）会一直存在于内存中，不会被JS的垃圾回收机制回收。 闭包函数实现了对其他函数内部变量的访问。（函数内部的变量对外是无法访问的，闭包通过这种变通的方法，实现了访问。） 用途 访问函数内部的变量 让变量始终保持在内存中 使用不当会导致内存泄漏 new 的原理 创建一个空对象作为返回实例 将这个空对象的原型，指向构造函数的prototype属性 将这个空对象赋值给构造函数内部的this关键字 开始执行构造函数内部的代码 返回这个对象12345function myNew(fn,...arg)&#123; let obj = Object.create(fn.prototype) let result = fn.apply(obj,arg) return typeof result === &#x27;object&#x27; ? result : obj; &#125; 原型与原型链&amp;emsp;&amp;emsp;在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数 123person1.constructor == PersonPerson.prototype.constructor = Personperson1.__proto__ == Person.prototype 注意： 原型对象（Person.prototype）是 构造函数（Person）的一个实例。原型与原型链参考文章 事件处理机制 捕获阶段：事件从window对象自上而下向目标节点传播的阶段； 目标阶段：真正的目标节点正在处理事件的阶段； 冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。 模块化&amp;emsp;&amp;emsp;模块化开发是一种管理方式，一种生产方式，一种解决问题的方案。一个模块就是实现某个特定功能的文件，我们可以很方便的使用别人的代码，想要什么模块，就引入那个模块。 &amp;emsp;&amp;emsp;防止出现命名冲突，污染作用域等一系列问题 Iterator迭代器&amp;emsp;&amp;emsp;迭代器对象本质上，就是一个指针对象。通过指针对象的next(), 用来移动指针。 1234567891011&lt;!--JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。--&gt;var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]; for (let a in arr) &#123; console.log(a); // 0 1 2 3&#125; for (let a of arr) &#123; console.log(a); // a b c d&#125; Promisepromise共有三种状态，pending,fulfilled,rejected 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 自定义实现promiseclass MyPromise &#123; constructor(executor) &#123; let _this = this this.state = &#x27;pending&#x27; // 当前状态 this.value = undefined // 存储成功的值 this.reason = undefined // 存储失败的值 // 利用发布订阅模式，让Promise支持异步 this.onFulfilledFunc = [] // 存储成功的回调 this.onRejectedFunc = [] // 存储失败的回调 function resolve (value) &#123; // Promise对象已经由pending状态改变为了成功态（resolved）或是失败态（rejected）就不能再次更改状态了。因此我们在更新状态时要判断，如果当前状态是pending（等待态）才可更新 if (_this.state === &#x27;pending&#x27;) &#123; _this.value = value //依次执行成功回调 _this.onFulfilledFunc.forEach(fn =&gt; fn(value)) _this.state = &#x27;resolved&#x27; &#125; &#125; function reject (reason) &#123; // Promise对象已经由pending状态改变为了成功态（resolved）或是失败态（rejected）就不能再次更改状态了。因此我们在更新状态时要判断，如果当前状态是pending（等待态）才可更新 if (_this.state === &#x27;pending&#x27;) &#123; _this.reason = reason //依次执行失败回调 _this.onRejectedFunc.forEach(fn =&gt; fn(reason)) _this.state = &#x27;rejected&#x27; &#125; &#125; try &#123; // 当实例化Promise时，构造函数中就要马上调用传入的executor函数执行 executor(resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125; _resolvePromise (promise2, x, resolve, reject) &#123; // 如果返回了自己的Promise对象，状态永远为等待态（pending），再也无法成为resolved或是rejected，程序会死掉，因此首先要处理它 if (promise2 === x) &#123; reject(new TypeError(&#x27;Promise存在循环引用&#x27;)) &#125; if (x !== null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)) &#123; // x可能是一个promise try &#123; let then = x.then if (typeof then === &#x27;function&#x27;) &#123; then.call(x, (y) =&gt; &#123; _resolvePromise(promise2, y, resolve, reject) &#125;) &#125; else &#123; resolve(x) &#125; &#125; catch (err) &#123; reject(err) &#125; &#125; else &#123; //否则是个普通值 resolve(x) &#125; &#125; then (onFulfilled, onRejected) &#123; let promise2 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : function (val) &#123; return val &#125; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : function (reason) &#123; throw reason &#125; if (this.state === &#x27;resolved&#x27;) &#123; promise2 = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value) this._resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) &#125; if (this.state === &#x27;rejected&#x27;) &#123; promise2 = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason) this._resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) &#125; if (this.state === &#x27;pending&#x27;) &#123; promise2 = new MyPromise((resolve, reject) =&gt; &#123; this.onFulfilledFunc.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value) this._resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) this.onRejectedFunc.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason) this._resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) &#125;) &#125; return promise2 &#125;&#125; Generator什么是Generator&amp;emsp;&amp;emsp;是ES6提供的一种异步编程解决方案，语法不同于普通函数；简单的把Generator 理解为一个状态机，封装了多个内部状态。执行Generator 函数会返回一个迭代器对象，可以通过调用迭代器next依次遍历Generator函数内部的每一个状态。 Generator的特征 function关键字与函数名之间有个星号； 函数内部使用yield表达式 Generator的使用1234567891011function* generateSequence() &#123; yield 1; yield 2; return 3;&#125;let generator = generateSequence();let one = generator.next();alert(JSON.stringify(one)); // &#123;value: 1, done: false&#125; async&#x2F;await&amp;emsp;&amp;emsp;声明异步函数,遇到await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，继续执行await后面的代码。 优缺点： 相对于promise，async&#x2F;await处理 then 的调用链，代码要清晰很多，几乎和同步代码一样 滥用 await 可能会导致性能问题，因为 await 会阻塞代码 事件循环定义&amp;emsp;&amp;emsp;事件循环，把异步任务的回调部分交给事件循环，等时机合适交还给 JS 线程执行。事件循环并不是 JavaScript 首创的，它是计算机的一种运行机制。&amp;emsp;&amp;emsp;所有任务都可以分成同步任务和异步任务，当任务进入执行栈，会判断任务是同步还是异步任务，如果是同步任务进行主线程，异步任务进入异步队列(event Queue),等待主线程中的任务执行完毕后，会在异步队列中读取相应的任务(先进先出)，推入主线程执行，这个上述过程不断重复就是事件循环（Event Loop） &amp;emsp;&amp;emsp;事件循环是由一个队列组成的，异步任务的回调遵循先进先出，在 JS 引擎空闲时会一轮一轮地被取出，所以被叫做循环。 垃圾回收(GC)&amp;emsp;&amp;emsp;是清理程序不用的内存或者是之前用过了，以后不会再用的内存空间。 回收策略&amp;emsp;&amp;emsp;垃圾回收主要也是针对堆内存中的对象，对于栈中的非闭包变量，会被栈执行上下文切换时直接出栈，释放了内存空间 内存泄漏 内存泄漏：当不再用到的对象内存，没有及时被回收，想要避免就让无用数据不存在引用关系。 内存膨胀：即在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用。 频繁GC: GC执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收。 泄露类型 闭包 隐式全局变量 DOM引用 定时器 事件监听 事件监听发布 Map、Set强引用 未清理的console 深浅拷贝浅拷贝&amp;emsp;&amp;emsp;会在栈中开辟另一块空间，并将被拷贝对象的栈内存数据完全拷贝到该块空间中，即基本数据类型的值会被完全拷贝，而引用类型的值则是拷贝了“指向堆内存的地址”。 123456789101112131415function shallowCopy(target) &#123; // 引用类型需要开辟一个新的存储地址 if (typeof target === &#x27;object&#x27; &amp;&amp; target !== null) &#123; const copy = Array.isArray(target) ? [] : &#123;&#125; for (const prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; copy[prop] = target[prop] &#125; &#125; return copy &#125; // 如果是基础类型就直接返回 return target&#125; 深拷贝&amp;emsp;&amp;emsp;不仅会在栈中开辟另一块空间，若被拷贝对象中有引用类型，则还会在堆内存中开辟另一块空间存储引用类型的真实数据。 1JSON.parse(JSON.stringify(obj)) 1234567891011121314151617181920212223242526272829303132333435const obj3 = &#123; func: function() &#123;console.log(1)&#125;, obj: &#123; name: &#x27;h&#x27; , data: &#123; fn: function() &#123; console.log(&#x27;data&#x27;) &#125;, child: &#x27;child&#x27; &#125;&#125;, arr: [1,2,3], und: undefined, ref: /^123$/, date: new Date(), NaN: NaN, infinity: Infinity, sym: Symbol(1)&#125;function deepCopy(obj, hash = new WeakMap) &#123; // 日期类型直接返回一个新的日期对象 if (obj instanceof Date) return new Date(obj) // 正则对象直接返回新的正则对象 if (obj instanceof RegExp) return new RegExp(obj) // 循环引用使用 weakMap 解决 if (hash.has(obj)) return hash.get(obj) const desc = Object.getOwnPropertyDescriptors(obj) // 获取原型上的方法和对象的描述信息，创建新的对象 const copyObj = Object.create(Object.getPrototypeOf(obj), desc) hash.set(obj, copyObj) // 循环递归遍历内容，防止还会有共计内存的问题 for (const key of Reflect.ownKeys(obj)) &#123; let item = obj[key] if (typeof item === &#x27;object&#x27; &amp;&amp; item !== null &amp;&amp; typeof item !== &#x27;function&#x27;) &#123; copyObj[key] = deepCopy(item) &#125; else &#123; copyObj[key] = item &#125; &#125; return copyObj&#125;console.log(deepCopy(obj3)) 深拷贝和浅拷贝的区分&amp;emsp;&amp;emsp;简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短；如果B没变，那就是深拷贝，自食其力。 节流和防抖&amp;emsp;&amp;emsp;在进行窗口的resize、scroll、输出框内容校验等操纵的时候，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常之差。那么为了前端性能的优化也为了用户更好的体验，就可以采用防抖（debounce）和节流（throttle）的方式来到达这种效果，减少调用的频率。 防抖&amp;emsp;&amp;emsp;一定在事件触发 n 秒后才执行，如果在一个事件触发的 n 秒内又触发了这个事件，以新的事件的时间为准，n 秒后才执行，等触发事件 n 秒内不再触发事件才执行。 即计最后一次触发 12345678910111213141516171819202122232425function debounce(func, wait, immediate) &#123; var timeout, result; function debounced () &#123; var context = this, args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(function() &#123; result = func.apply(context, args) &#125;, wait); if (callNow) result = func.apply(context, args); &#125; else &#123; timeout = setTimeout(function() &#123; result = func.apply(context, args) &#125;, wait); &#125; return result; &#125; debounced.cancel = function()&#123; cleatTimeout(timeout); timeout = null; &#125; return debounced;&#125; 节流&amp;emsp;&amp;emsp;当持续触发事件时，保证一定时间段内只调用一次事件处理函数。即计第一次触发 123456789101112131415161718192021222324function throttle(func, wait) &#123; var timer = null; var startTime = Date.now(); return function()&#123; var curTime = Date.now(); var remaining = wait-(curTime-startTime); var context = this; var args = arguments; clearTimeout(timer); if(remaining&lt;=0)&#123; func.apply(context, args); startTime = Date.now(); &#125;else&#123; timer = setTimeout(fun, remaining); // 如果小于wait 保证在差值时间后执行 &#125; &#125;&#125; Proxy代理&amp;emsp;&amp;emsp;Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 123// target:要使用 Proxy 包装的目标对象// handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时，代理 p 的行为const p = new Proxy(target, handler) &amp;emsp;&amp;emsp;Proxy可以帮我们对数据的处理，对构造函数的处理，对数据的验证，说白了，就是在我们访问对象前添加了一层拦截，可以过滤很多操作，而这些过滤，由你来定义。 Ajax定义&amp;emsp;&amp;emsp;Ajax 异步通信技术，是Asynchronous JavaScript+XML的简写，这种技术允许向服务器请求额外的数据而无需卸载（刷新）页面。 通信步骤 新建XMLHttpRequest对象 打开要发送的地址通道 给XMLHttpRequest对象增加侦听器，用来侦听各种情况 发送数据给打开的地址 数组方法 join()：用指定的分隔符将数组每一项拼接为字符串 push()：向数组的末尾添加新元素 pop()：删除数组的最后一项 unshift()：向数组首位添加新元素 shift()：删除数组的第一项 slice()：按照条件查找出其中的部分元素 splice()：对数组进行增删改 filter()：过滤功能 concat()：用于连接两个或多个数组 indexOf()：检测当前值在数组中第一次出现的位置索引 lastIndexOf()：检测当前值在数组中最后一次出现的位置索引 every()：判断数组中每一项都是否满足条件 some()：判断数组中是否存在满足条件的项 includes()：判断一个数组是否包含一个指定的值 sort()：对数组的元素进行排序 reverse()：对数组进行倒序 forEach()：es5及以下循环遍历数组每一项 map()：es6循环遍历数组每一项 find()：返回匹配的项 findIndex()：返回匹配位置的索引 reduce()：从数组的第一项开始遍历到最后一项，返回一个最终的值 reduceRight()：从数组的最后一项开始遍历到第一项，返回一个最终的值 toLocaleString()、toString()：将数组转换为字符串 entries()、keys()、values()：遍历数组 ES6新特性let const let：使用let声明的变量具有块级作用域:，只能在当前声明的代码块中使用，必须要先声明再使用 const：具有块级作用域的特点，只能在当前声明的代码块中使用，必须要先声明再使用。常量，声明时必须赋值，不能改 箭头函数 可以将箭头函数赋值给一个变量，变量名字就是函数的名字，通过变量名字调用函数。 如果函数体中只有一行代码，且代码的执行结果就是返回值，可以省略大括号。 如果形参只有一个，可以省略小括号（如果没有形参，小括号不能省略） 解构赋值新增基本数据类型 Sybmol模块化 import导入 export导出promise新增类class关键字","categories":[{"name":"面经","slug":"面经","permalink":"https://1518277259.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"CSS解析","slug":"CSS解析","date":"2022-09-21T08:24:51.000Z","updated":"2023-03-02T13:21:21.115Z","comments":true,"path":"2022/09/21/CSS解析/","link":"","permalink":"https://1518277259.github.io/2022/09/21/CSS%E8%A7%A3%E6%9E%90/","excerpt":"","text":"CSS解析盒子模型(box-sizing) 盒子模型包括了四部分，margin、padding、border、content 分为IE盒子模型(border-sizing)和标准盒子模型(content-sizing) ie 盒子模型的width&#x2F;height 包含了padding和border 标准盒模型的width&#x2F;height 不包含padding和border position包含几种属性 static：默认状态，没有定位，正常流 fixed：生成绝对定位元素，相对于浏览器窗口定位 absolute:生成绝对定位元素，相对于与static定位外的第一个父元素定位 relative:生成相对定位元素 sticky:粘性定位，sticky元素效果完全受制于父级元素们 CSS选择器及优先级 选择器 格式 优先级权重 id选择器 #id 100 类选择器 .className 10 属性选择器 a[ref&#x3D;’eee’] 10 伪类选择器 li:last-child 10 标签选择器 div 1 伪元素选择器 li:after 1 相邻兄弟选择器 h1+p 0 子选择器 ul&gt;li 0 后代选择器 li a 0 通配符选择器 * 0 注： !important优先级最高 优先级相同情况下，最后出现的样式生效 继承得到的样式的优先级最低； display的属性及作用 属性 作用 none 元素不显示，从文档流中移除 block 块类型，默认是父元素的宽度，可设置宽高，换行显示 inline 行内元素类型，默认宽度为内容宽度，同行显示 inline-block 默认宽度为内容宽度，可设置宽高，同行显示 list-item 向块元素一样显示，并添加样式列表标记 table 此元素会作为块级表格显示 inherit 从父元素继承display属性的值 BFC(块级格式化上下文)定义通俗来说BFC就是容器，用来管理内部块级元素，与这个区域外无关 特性 BFC会阻止垂直外边距折叠 BFC不会重叠浮动元素 BFC可以包含浮动—-清除浮动 Flex布局flex-direction:决定主轴的方向(即项目的排列方向) 12345678.container &#123; flex-direction: row | row-reverse | column | column-reverse; // row，主轴为水平方向，起点在左端。 // row-reverse：主轴为水平方向，起点在右端 // column：主轴为垂直方向，起点在上沿 // column-reverse：主轴为垂直方向，起点在下沿&#125; flex-wrap:决定容器内项目是否可换行 123456.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125;// nowrap 不换行,自动调整尺寸// wrap：项目主轴总尺寸超出容器时换行，第一行在上方// wrap-reverse：换行，第一行在下方 flex-flow: (忽略)flex-direction 和 flex-wrap 的简写形式 1234.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content：定义了项目在主轴的对齐方式。 123456789.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around; // flex-start 左对齐 // flex-end：右对齐 // center：居中 // space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。 // space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。&#125; align-items:定义了项目在交叉轴上的对齐方式 12345678.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125;// flex-start：交叉轴的起点对齐// flex-end：交叉轴的终点对齐// center：交叉轴的中点对齐// baseline: 项目的第一行文字的基线对齐// align-content:定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用 12345678910.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125;// flex-start：轴线全部在交叉轴上的起点对齐// flex-end：轴线全部在交叉轴上的终点对齐// center：轴线全部在交叉轴上的中间对齐// space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。// space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。 清除浮动1234567// 父级div定义伪类:after和zoom.contain:after&#123; clear:both; content:&quot;&quot;; visibility:hidden;&#125; link 和 @import 的区别link并行下载@import 引入的资源编译、加载、执行完成后才会执行后续为性能提高建议使用link CSS动画和过渡transition强调的是单一属性的动画效果，从开始到结束整个过程中间不会发生动画的转折 animation强调的是多种动画属性的结合，能够有效的排列动画执行的时间 某时做某事 ，可以简单也可以复杂 CSS优化和提高性能加载性能 css压缩 css单一样式 减少使用@import，建议使用link，因为前者是等待页面加载完成在加载CSS,后者是同时加载 选择器性能 避免使用通配规则 尽量少使用标签进行选择，用id或class 渲染性能 慎重使用高性能属性：浮动、定位 尽量减少页面的重排 属性值为0时不加单位 标准化各种浏览器前缀，带浏览器前缀的在前，标准属性在后 优化嵌套，避免层级太深 使用CSS雪碧图，减少http请求","categories":[{"name":"面经","slug":"面经","permalink":"https://1518277259.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"HTML解析","slug":"HTML解析","date":"2022-08-21T08:24:51.000Z","updated":"2023-03-02T13:21:12.899Z","comments":true,"path":"2022/08/21/HTML解析/","link":"","permalink":"https://1518277259.github.io/2022/08/21/HTML%E8%A7%A3%E6%9E%90/","excerpt":"","text":"HTML 解析meta 标签：自动刷新&#x2F;跳转123// 5s 之后自动跳转到同域下的 page2.html 页面&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5; URL=page2.html&quot;&gt; 123//每隔一分钟就需要刷新页面的大屏幕监控&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;60&quot;&gt; 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt;&lt;meta charset=’utf-8′&gt; &lt;!--声明文档使用的字符编码--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; &lt;!--优先使用 IE 最新版本和 Chrome--&gt;&lt;meta name=”description” content=”不超过150个字符”/&gt; &lt;!--页面描述--&gt;&lt;meta name=”keywords” content=””/&gt; &lt;!-- 页面关键词--&gt;&lt;meta name=”author” content=”name, email@gmail.com”/&gt; &lt;!--网页作者--&gt;&lt;meta name=”robots” content=”index,follow”/&gt; &lt;!--搜索引擎抓取--&gt;&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; &lt;!--为移动设备添加 viewport--&gt;&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt;&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; &lt;!--添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;&lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--&gt;&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt; &lt;!--设置苹果工具栏颜色--&gt;&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; &lt;!--避免IE使用兼容模式--&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; &lt;!--不让百度转码--&gt;&lt;meta name=”HandheldFriendly” content=”true”&gt; &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--&gt;&lt;meta name=”MobileOptimized” content=”320″&gt; &lt;!--微软的老式浏览器--&gt;&lt;meta name=”screen-orientation” content=”portrait”&gt; &lt;!--uc强制竖屏--&gt;&lt;meta name=”x5-orientation” content=”portrait”&gt; &lt;!--QQ强制竖屏--&gt;&lt;meta name=”full-screen” content=”yes”&gt; &lt;!--UC强制全屏--&gt;&lt;meta name=”x5-fullscreen” content=”true”&gt; &lt;!--QQ强制全屏--&gt;&lt;meta name=”browsermode” content=”application”&gt; &lt;!--UC应用模式--&gt;&lt;meta name=”x5-page-mode” content=”app”&gt; &lt;!-- QQ应用模式--&gt;&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; &lt;!--windows phone 点击无高亮设置页面不缓存--&gt;&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt; viewport12&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt; html语义化的了解 内容结构化，结构更清晰 便于搜索引擎解析 便于阅读理解维护 Html新特性 语义化标签：article、footer、header、nav、section 表单控件：calendar、date、time、email、url、search 媒体元素：video、audio 本地存储：localStorage、sessionStorage 新技术：websocket、webworker src和link的区别src：引用资源替换当前元素，用在img、script、iframe 当浏览器解析到src会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，这是为什么建议将js脚本放在底部而不是头部的原因 link：在当前元素和引用资源间建立连接，用在link和a等元素上 在文档中添加href，浏览器会识别该文档为CSS文件，并行下载资源并不会停止对当前文档的处理，这个数为什么建议使用link方式加载CSS而不是@import方式","categories":[{"name":"面经","slug":"面经","permalink":"https://1518277259.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"html","slug":"html","permalink":"https://1518277259.github.io/tags/html/"}]},{"title":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","date":"2022-04-15T01:37:43.000Z","updated":"2022-04-15T01:38:33.621Z","comments":true,"path":"2022/04/15/深拷贝和浅拷贝/","link":"","permalink":"https://1518277259.github.io/2022/04/15/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"浅拷贝只复制引用，而未复制真正的值 1234567891011121314151617const originArray = [1,2,3,4,5];const originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const cloneArray = originArray;const cloneObj = originObj;console.log(cloneArray); // [1,2,3,4,5]console.log(originObj); // &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:Array[3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;cloneArray.push(6);cloneObj.a = &#123;aa:&#x27;aa&#x27;&#125;;console.log(cloneArray); // [1,2,3,4,5,6]console.log(originArray); // [1,2,3,4,5,6]console.log(cloneObj); // &#123;a:&#123;aa:&#x27;aa&#x27;&#125;,b:&#x27;b&#x27;,c:Array[3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;console.log(originArray); // &#123;a:&#123;aa:&#x27;aa&#x27;&#125;,b:&#x27;b&#x27;,c:Array[3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125; 深拷贝深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。 实现深拷贝的两种方法JSON.stringify&#x2F;parse的方法 如果对象含有一个函数时，不能用这个方法进行深拷贝，因为undefine、function、symbol会在转换过程中被忽略 1234567891011121314const originArray = [1,2,3,4,5];const cloneArray = JSON.parse(JSON.stringify(originArray));console.log(cloneArray === originArray); // falseconst originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const cloneObj = JSON.parse(JSON.stringify(originObj));console.log(cloneObj === originObj); // falsecloneObj.a = &#x27;aa&#x27;;cloneObj.c = [1,1,1];cloneObj.d.dd = &#x27;doubled&#x27;;console.log(cloneObj); // &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;console.log(originObj); // &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;; 递归的方法 1234567891011121314function deepClone(source)&#123; const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象 for(let keys in source)&#123; // 遍历目标 if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === &#x27;object&#x27;)&#123; // 如果值是对象，就递归一下 targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; // 如果不是，就直接赋值 targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125; 总结 赋值运算符 &#x3D; 实现的是浅拷贝，只拷贝对象的引用值； JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”； JSON.stringify 实现的是深拷贝，但是对目标对象有要求； 若想真正意义上的深拷贝，请递归。","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"Promise","slug":"Promise","date":"2022-04-15T01:14:04.000Z","updated":"2022-04-15T01:15:12.696Z","comments":true,"path":"2022/04/15/Promise/","link":"","permalink":"https://1518277259.github.io/2022/04/15/Promise/","excerpt":"","text":"定义Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 状态 在 pending 状态，promise 可以切换到 fulfilled 或 rejected。 在 fulfilled 状态，不能迁移到其它状态，必须有个不可变的 value。 在 rejected 状态，不能迁移到其它状态，必须有个不可变的 reason。 12345678910111213141516171819202122232425function MyPromise(fn) &#123; let self = this; // 缓存当前promise实例 self.value = null; //成功时的值 self.error = null; //失败时的原因 self.onFulfilled = null; //成功的回调函数 self.onRejected = null; //失败的回调函数 function resolve(value) &#123; self.value = value; self.onFulfilled(self.value);//resolve时执行成功回调 &#125; function reject(error) &#123; self.error = error; self.onRejected(self.error)//reject时执行失败回调 &#125; fn(resolve, reject);&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; //在这里给promise实例注册成功和失败回调 this.onFulfilled = onFulfilled; this.onRejected = onRejected;&#125;module.exports = MyPromise","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"原型和原型链","slug":"原型和原型链-1","date":"2022-04-14T02:19:01.000Z","updated":"2022-04-14T03:07:14.043Z","comments":true,"path":"2022/04/14/原型和原型链-1/","link":"","permalink":"https://1518277259.github.io/2022/04/14/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-1/","excerpt":"","text":"原型 原型链每个对象拥有一个原型对象，通过 __proto__ 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。 小结 Symbol 作为构造函数来说并不完整，因为不支持语法 new Symbol()，但其原型上拥有 constructor 属性，即 Symbol.prototype.constructor。 引用类型 constructor 属性值是可以修改的，但是对于基本类型来说是只读的，当然 null 和 undefined 没有 constructor 属性。 __proto__ 是每个实例上都有的属性，prototype 是构造函数的属性，这两个并不一样，但 p.__proto__ 和 Parent.prototype 指向同一个对象。 __proto__ 属性在 ES6 时被标准化，但因为性能问题并不推荐使用，推荐使用 Object.getPrototypeOf()。 每个对象拥有一个原型对象，通过 __proto__ 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null，这就是原型链。","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"call、apply、bind简介","slug":"call、apply、bind简介","date":"2022-04-13T01:34:55.000Z","updated":"2022-04-13T01:35:38.711Z","comments":true,"path":"2022/04/13/call、apply、bind简介/","link":"","permalink":"https://1518277259.github.io/2022/04/13/call%E3%80%81apply%E3%80%81bind%E7%AE%80%E4%BB%8B/","excerpt":"","text":"callcall 是属于所有 Function 的方法，也就是 Function.prototype.call。 12fun.call(thisArg[,arg1[,arg2,…]]); 使用 call 调用函数并且指定 this123456789var obj = &#123; a: 1&#125;function foo(b, c)&#123; this.b = b; this.c = c; console.log(this.a + this.b + this.c);&#125;foo.call(obj,2,3); // 6 call 实现继承12345678910111213141516function Person(name, age)&#123; this.name = name; this.age = age; this.say = function()&#123; console.log(this.name + &quot;:&quot; + this.age); &#125;&#125;function Student(name, age, job)&#123; Person.call(this, name ,age); this.job = job; this.say = function()&#123; console.log(this.name + &quot;:&quot; + this.age + &quot; &quot; + this.job); &#125;&#125;var me = new Student(&quot;axuebin&quot;,25,&quot;FE&quot;);console.log(me.say()); // axuebin:25 FE applyapply 也是属于所有 Function 的方法，也就是 Function.prototype.apply。 1fun.apply(thisArg, [argsArray]) 和 call 用法一样，只是参数不同，call 的参数是列表，将每个参数都列出来；apply 的参数是数组，将每个参数放到一个数组中 完整的 apply1234567891011121314151617Function.prototype.myApply=function(context)&#123; // 获取调用`myApply`的函数本身，用this获取，如果context不存在，则为window var context = context || window; var fn = Symbol(); context[fn] = this; //获取传入的数组参数 var args = arguments[1]; if (args == undefined) &#123; //没有传入参数直接执行 // 执行这个函数 context[fn]() &#125; else &#123; // 执行这个函数 context[fn](...args); &#125; // 从上下文中删除函数引用 delete context.fn;&#125; bindbind()方法创建一个新的函数,当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 12fun.bind(thisArg[, arg1[, arg2[, ...]]]) 例子： 12345678910function Person(name)&#123; this.name = name; this.say = function()&#123; setTimeout(function()&#123; console.log(&quot;hello &quot; + this.name); &#125;.bind(this),1000) &#125;&#125;var person = new Person(&quot;axuebin&quot;);person.say(); //hello axuebin 总结 三者都是用来改变函数的 this 指向 三者的第一个参数都是 this 指向的对象 bind 是返回一个绑定函数可稍后执行，call、apply 是立即调用 三者都可以给定参数传递 call 给定参数需要将参数全部列出，apply 给定参数数组","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"执行上下文、作用域链、闭包","slug":"执行上下文、作用域链、闭包","date":"2022-04-12T06:26:26.000Z","updated":"2022-04-12T06:30:59.164Z","comments":true,"path":"2022/04/12/执行上下文、作用域链、闭包/","link":"","permalink":"https://1518277259.github.io/2022/04/12/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85/","excerpt":"","text":"执行上下文执行上下文是评估和执行 JavaScript 代码的环境的抽象概念 类型 全局执行上下文 12它创建会执行两件事：创建一个全局的window对象，并设置this的值等于这个全局的对象。一个程序只会有一个全局对象 函数执行上下文 12每个函数都有它自己的执行上下文，不过是在函数被调用时创建的；this的值取决于该函数是怎样被调用的，如果是被一个对象引用调用，指向这个对象，否则指向全局对象 Eval 函数执行上下文 1执行在 eval 函数内部的代码也会有它属于自己的执行上下文 执行顺序当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。 作用域作用域决定这个变量的生命周期及其可见性。 当我们创建了一个函数或者 {} 块，就会生成一个新的作用域 作用域链当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"}]},{"title":"在地址栏里输入一个地址回车会发生哪些事情","slug":"在地址栏里输入一个地址回车会发生哪些事情","date":"2022-04-11T03:36:45.000Z","updated":"2022-04-11T03:38:52.997Z","comments":true,"path":"2022/04/11/在地址栏里输入一个地址回车会发生哪些事情/","link":"","permalink":"https://1518277259.github.io/2022/04/11/%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%87%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%E5%9B%9E%E8%BD%A6%E4%BC%9A%E5%8F%91%E7%94%9F%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/","excerpt":"","text":"解析 URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。 缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。 DNS 解析：下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。 获取 MAC 地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 TCP 三次握手：下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。 HTTPS 握手：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。 返回数据：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 页面渲染：浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。 TCP 四次挥手：最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"TCP和UDP的区别","slug":"TCP和UDP的区别","date":"2022-04-11T03:30:48.000Z","updated":"2022-04-11T03:31:31.095Z","comments":true,"path":"2022/04/11/TCP和UDP的区别/","link":"","permalink":"https://1518277259.github.io/2022/04/11/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"TCP UDP TCP 是面向连接的协议 UDP 的无连接的协议 TCP 在发送数据前需要建立连接 UDP 无需建立连接就可以发送大量数据 TCP 回按照特定的顺序重新排列数据包 UDP 数据包没有固定顺序，所有数据包相互独立 TCP 传输速度比较慢 UDP 的传输会更快 TCP 的头部字节有 20 字节 UDP 的头部字节只需要 8 个字节 TCP 是重量级的，在发送数据前需要进行三次握手建立连接 UDP 是轻量级的，没有跟踪链接，消息排序 TCP 会进行错误校验，并进行错误恢复 UDP 也会进行错误检查，但会丢掉错误的数据包 TCP 有发送确认 UDP 没有发送确认 TCP 会使用握手协议 无握手协议 TCP 是可靠的，可以确保将数据传送到路由器 在 UDP 中不能确保数据传送到目标","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"GEI和POST的区别","slug":"GEI和POST的区别","date":"2022-04-11T03:03:49.000Z","updated":"2022-04-11T03:29:41.055Z","comments":true,"path":"2022/04/11/GEI和POST的区别/","link":"","permalink":"https://1518277259.github.io/2022/04/11/GEI%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"数据传输方式不同：GET 请求通过 URL 传输数据，而 POST 的数据通过请求体传输。 安全性不同：POST 的数据因为在请求主体内，所以有一定的安全性保证，而 GET 的数据在 URL 中，通过历史记录，缓存很容易查到数据信息。 数据类型不同：GET 只允许 ASCII 字符，而 POST 无限制 GET 无害： 刷新、后退等浏览器操作 GET 请求是无害的，POST 可能重复提交表单 特性不同：GET 是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而 POST 是非安全非幂等","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"HTTP和HTTPS的区别","slug":"HTTP和HTTPS的区别","date":"2022-04-11T02:54:56.000Z","updated":"2022-04-11T03:03:29.058Z","comments":true,"path":"2022/04/11/HTTP和HTTPS的区别/","link":"","permalink":"https://1518277259.github.io/2022/04/11/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"http 是客户端和服务器请求和应答的标准的(TCP)超文本传输协议，使浏览器更高效，网络传输减少；https 简单来说就是 http+SSL，作用 1 是建立信息安全通道，保证数据传输安全，2 是确认网站真实性 https 协议需要证书，一般免费证书少，需要一定费用； http 是超文本传输协议，信息是明文传输；https 则是具有 ssl 加密的传输协议 连接方式不同，端口不同，http:80 https:443 http 连接是无状态的；https 协议是有 SSL+Http 协议构成的可进行加密传输、身份认证的网络协议，比 http 协议更安全。","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"HTTP状态码简介","slug":"HTTP状态码简介","date":"2022-04-11T02:36:27.000Z","updated":"2022-04-11T02:50:04.481Z","comments":true,"path":"2022/04/11/HTTP状态码简介/","link":"","permalink":"https://1518277259.github.io/2022/04/11/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一、1 开头1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 二、2 开头2xx (成功)表示成功处理了请求的状态代码 200 (成功) 服务器已成功处理了请求，通常表示服务器提供了请求的网关 201 (已创建) 请求成功并且服务器创建了新的资源。 202 (已接受) 服务器已接受请求，但尚未处理。 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。 206 (部分内容) 服务器成功处理了部分 GET 请求。 三、3 开头3xx (重定向) 表示要完成请求，需要进一步操作。 通常这些状态代码用来重定向 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 四、4 开头4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理 400 (错误请求) 服务器不理解请求的语法。 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 (禁止) 服务器拒绝请求。 404 (未找到) 服务器找不到请求的网页。 405 (方法禁用) 禁用请求中指定的方法。 406 (不接受) 无法使用请求的内容特性响应请求的网页。 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。 408 (请求超时) 服务器等候请求时发生超时。 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 (未满足期望值) 服务器未满足”期望”请求标头字段的要求。 五、5 开头5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。 六、适用场景 100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输 206：一般用来做断点续传，或者是视频文件等大文件的加载 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分 400：参数有误，请求无法被服务器识别 403：告诉客户端禁止访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时 503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503 504：网关超时","categories":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2022-04-11T02:24:51.000Z","updated":"2022-04-11T02:33:56.133Z","comments":true,"path":"2022/04/11/git常用命令/","link":"","permalink":"https://1518277259.github.io/2022/04/11/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git branch 查看本地所有分支git status 查看当前状态git commit 提交 git branch -a 查看所有分支git branch -r 查看远程所有分支git commit -am ‘注释’ 提交并添加注释git push origin master 将文件推送到服务器git remote show origin 显示远程库 origin 中的资源git checkout –track origin&#x2F;dev 切换到远程 dev 分支git checkout -D master dev 删除本地库 devgit checkout -b dev 建立一个新的本地分支git merge origin&#x2F;dev 将分支 dev 与当前分支合并git checkout dev 切换成本地分支git remote show 查看远程库git add . 将文件添加到本地库git rm 文件名(包括路径) 从 git 删除指定文件 git clone 从服务器上将代码拉下来git config –list 看所有用户git ls-files 看已经被提交的git log 看 commit 的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm –cached a.a 移除文件(只从暂存区中删除)git commit -m “remove” 移除文件(从 Git 中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff –cached 或 $ git diff –staged 查看尚未提交的更新git stash push 将文件给 push 到一个临时空间中git stash pop 将文件从临时空间 pop 下来","categories":[{"name":"git","slug":"git","permalink":"https://1518277259.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://1518277259.github.io/tags/git/"}]},{"title":"Vue脚手架创建","slug":"Vue脚手架创建","date":"2022-03-31T07:09:43.000Z","updated":"2022-03-31T07:10:50.857Z","comments":true,"path":"2022/03/31/Vue脚手架创建/","link":"","permalink":"https://1518277259.github.io/2022/03/31/Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA/","excerpt":"","text":"Vue是什么Vue是一套用于构建用户界面的渐进式Javascript框架 Vue的特点 采用组件化模式，提高代码复用率，让代码更好维护 采用声明式编码，让开发人员无需操作DOM，提高开发效率 使用虚拟DOM和diff算法，尽量复用DOM节点 Vue脚手架网速原因先配置淘宝镜像 1npm config set registry https://registry.npm.taobao.org 全局安装@vue&#x2F;cli 1npm install -g @vue/cli 切换到你要创建的目录，使用命令行创建项目XXX 1vue create XXX 启动项目 123npm installnpm run dev/serve 使用命令查看项目的webpack打包配置 1vue inspect &gt; output.js Vue3 使用Vite创建1234567891011// 创建工程npm init vite-app &lt;project-name&gt;// 进入工程目录cd &lt;project-name&gt;// 安装依赖npm install// 运行npm run dev","categories":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/tags/vue/"}]},{"title":"元素居中","slug":"元素居中","date":"2022-03-29T11:05:26.000Z","updated":"2022-03-29T11:13:04.002Z","comments":true,"path":"2022/03/29/元素居中/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/","excerpt":"","text":"水平居中1.行内元素水平居中利用 text-align: center 可以实现在块级元素内部的行内元素水平居中。 此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。 12345.parent&#123; //在父容器设置 text-align:center; &#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent&#123; text-align:center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 2.块级元素的水平居中①、 将该块级元素左右外边距margin-left和margin-right设置为auto 1234.child&#123; width: 100px;//确保该块级元素定宽 margin:0 auto;&#125; ②、使用table+margin 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; ③、使用absolute+transform 12345678910111213&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position:absolute; left:50%; transform:translateX(-50%); &#125; .parent &#123; position:relative; &#125;&lt;/style&gt; ④、使用flex+justify-content 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content:center; &#125;&lt;/style&gt; ⑤、使用flex+margin 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 3、多块级元素水平居中①、利用flex布局 1234#container &#123; display: flex; justify-content: center;&#125; ②、利用inline-block 123456.container &#123;text-align: center;&#125;.inline-block &#123;display: inline-block;&#125; 4、浮动元素水平居中①、定宽的非浮动元素 12345678.child &#123; position:relative; left:50%; margin-left:-250px;&#125;&lt;div class=&quot;parent&quot;&gt; &lt;span class=&quot;child&quot; style=&quot;float: left;width: 500px;&quot;&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; ②、不定宽的浮动元素 1234567891011121314&lt;div class=&quot;box&quot;&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%;&#125;p&#123; float:left; position:relative; right:50%;&#125; ③、通用办法flex布局(不管是定宽还是不定宽) 123456789101112.parent &#123; display:flex; justify-content:center;&#125;.chlid&#123; float: left; width: 200px;//有无宽度不影响居中&#125;&lt;div class=&quot;parent&quot;&gt; &lt;span class=&quot;chlid&quot;&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 5、绝对定位元素水平居中123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt; .parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width: 200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0; /*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 垂直居中1.单行内联元素垂直居中1234567891011&lt;div id=&quot;box&quot;&gt; &lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 2.多行内联元素垂直居中①、利用flex布局（flex） 123456789101112131415&lt;div class=&quot;parent&quot;&gt; &lt;p&gt;Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is.&lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; ②、利用表布局（table） 1234567891011121314151617&lt;div class=&quot;parent&quot;&gt; &lt;p class=&quot;child&quot;&gt;The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know.&lt;/p&gt;&lt;/div&gt; &lt;style&gt; .parent &#123; display: table; height: 140px; border: 2px dashed #f69c55; &#125; .child &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 3 块级元素垂直居中①、使用absolute+负margin(已知高度宽度) 12345678910111213&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123;position: relative;&#125;.child &#123;position: absolute;top: 50%;height: 100px;margin-top: -50px;&#125; ②、使用absolute+transform 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123;position: relative;&#125;.child &#123;position: absolute;top: 50%;transform: translateY(-50%);&#125; ③、使用flex+align-items 12345678&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center;&#125; ④、使用table-cell+vertical-align 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 水平垂直居中1、绝对定位与负边距实现（已知高度宽度）123456789101112131415161718// css部分 #container &#123; position: relative; &#125; #center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; &#125; // html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id=&#x27;container&#x27;&gt; &lt;div id=&#x27;center&#x27; style=&quot;width: 100px;height: 100px;background-color: #666&quot;&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 2、绝对定位与margin:auto（已知高度宽度）123456789101112#container &#123; position: relative; height:100px;//必须有个高度 &#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 &#125; 3、绝对定位+CSS3(未知元素的高宽)12345678910#container &#123; position: relative; &#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; 4、flex布局1234567#container &#123;//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; &#125; 5、flex&#x2F;grid与margin:auto(最简单写法)12345678#container &#123; height: 100vh;//必须有高度 display: grid; &#125;#center &#123; margin: auto; &#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"实现三栏布局的方法","slug":"实现三栏布局的方法","date":"2022-03-29T08:53:29.000Z","updated":"2022-03-29T08:54:34.102Z","comments":true,"path":"2022/03/29/实现三栏布局的方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"浮动布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Layout&lt;/title&gt; &lt;style media=&quot;screen&quot;&gt; html * &#123; padding: 0; margin: 0; &#125; .layout article div &#123; min-height: 150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--浮动布局 --&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;style media=&quot;screen&quot;&gt; .layout.float .left &#123; float: left; width: 300px; background: red; &#125; .layout.float .center &#123; background: yellow; &#125; .layout.float .right &#123; float: right; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; // 右栏部分要写在中间内容之前 &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等。 绝对布局123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right&gt;div&#123; position: absolute;//三块都是绝对定位 &#125; .left &#123; left:0; width: 300px; background: red; &#125; .center &#123; right: 300px; left: 300px;//离左右各三百 background: yellow; &#125; .right &#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; 绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。 flex布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: flex; &#125; .left &#123; width: 300px; background: red; &#125; .center &#123; background: yellow; flex: 1; &#125; .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; lexbox布局是css3里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用flexbox。 flexbox的缺点就是IE10开始支持，但是IE10的是-ms形式的。 表格布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: table; height: 150px; width: 100%; &#125; .left-center-right&gt;div &#123; display: table-cell; &#125; .left &#123; width: 300px; background: red; &#125; .center &#123; background: yellow; &#125; .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; 表格布局的兼容性很好(见下图)，在flex布局不兼容的时候，可以尝试表格布局。当内容溢出时会自动撑开父元素。 表格布局也是有缺陷:①无法设置栏边距；②对seo不友好；③当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。 网格布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .left-center-right &#123; display: grid; width: 100%; grid-template-columns: 300px auto 300px; grid-template-rows: 150px; //行高 &#125; .left &#123; background: red; &#125; .center &#123; background: yellow; &#125; .right &#123; background: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; CSS Grid是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让Web设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"Flex布局","slug":"Flex布局","date":"2022-03-29T06:37:18.000Z","updated":"2022-03-29T06:41:36.594Z","comments":true,"path":"2022/03/29/Flex布局/","link":"","permalink":"https://1518277259.github.io/2022/03/29/Flex%E5%B8%83%E5%B1%80/","excerpt":"","text":"Flex 基本概念在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴 Flex 容器实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。如果你使用块元素如 div，你就可以使用 flex，而如果你使用行内元素，你可以使用 inline-flex。 需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 Flex属性1. flex-direction决定主轴的方向(即项目的排列方向) 1234567.container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; row，主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端column：主轴为垂直方向，起点在上沿column-reverse：主轴为垂直方向，起点在下沿 2. flex-wrap:决定容器内项目是否可换行 1234567891011.container &#123; flex-wrap: nowrap | wrap | wrap-reverse; &#125; 默认值：nowrap 不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。wrap：项目主轴总尺寸超出容器时换行，第一行在上方；wrap-reverse：换行，第一行在下方 3. flex-flow:flex-direction 和 flex-wrap 的简写形式 123456.container &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 默认值为: row nowrap，感觉没什么卵用，老老实实分开写就好了。这样就不用记住这个属性了。 4. justify-content：定义了项目在主轴的对齐方式。 12345678910111213.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 默认值: flex-start 左对齐flex-end：右对齐center：居中space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 5. align-items:定义了项目在交叉轴上的对齐方式 1234567891011.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐flex-end：交叉轴的终点对齐center：交叉轴的中点对齐baseline: 项目的第一行文字的基线对齐 6. align-content:定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用 12345678910111213.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：轴线全部在交叉轴上的起点对齐flex-end：轴线全部在交叉轴上的终点对齐center：轴线全部在交叉轴上的中间对齐space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"CSS高度塌陷","slug":"CSS高度塌陷","date":"2022-03-29T06:13:43.000Z","updated":"2022-03-29T11:14:13.490Z","comments":true,"path":"2022/03/29/CSS高度塌陷/","link":"","permalink":"https://1518277259.github.io/2022/03/29/CSS%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7/","excerpt":"","text":"1.什么是高度塌陷当父元素不设置高度的时候，靠子元素撑大；当子元素浮动后，父元素的高度就会塌陷；父元素下面的元素就会向上移动，导致整个页面混乱。 1234&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; 12345678910111213.box1 &#123; border: 10px red solid; &#125;.box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125;.box3 &#123; height: 100px; background-color: green; &#125; 2.解决方法方法一：给父元素设置高度，固定高度后父元素的高度无法适应子元素的高度。弊端： 不能让元素自适应 12345.box1 &#123; border: 10px red solid; height:100px; &#125; 方法二：给父元素设置overflow：hidden，解决高度塌陷并实现自适应，弊端： 只要里面的内容或元素超出父元素以外就会被隐藏。 1234.box1 &#123; border: 10px red solid; overflow: hidden; &#125; 方法三：在浮动元素下面添加一个空白元素，并给它设置一哈属性；弊端： 会添加很多空标记，增加结构负担，产生代码冗余 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; .clear_fix&#123; /*空白div的属性*/ clear:both; /*清除两侧浮动*/ height:0; overflow:hidden; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clear_fix&quot;&gt;&lt;/div&gt; /*添加空白div*/ &lt;/div&gt; &lt;/body&gt; 方法四：给父元素添加display:table；让父元素转换元素类型和表格一样弊端： 会改变当前元素的元素类型 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; display: table; /* 改变元素类型为表格 */ &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 方法五：万能清除法通过after伪类元素添加一个空白的块元素，css添加下列属性，并给要清除的div加上clear_fix的类名，无副作用。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box1 &#123; border: 10px red solid; &#125; .box2 &#123; width: 100px; height: 100px; background-color: blue; float: left; &#125; .clear_fix:after &#123; /* 要加的属性 */ content: &quot;&quot;; /* 添加内容 */ clear: both; /* 清楚两侧浮动 */ display: block; /* 转换元素类型为块元素 */ height: 0; overflow: hidden; /* 溢出隐藏属性 */ visibility: hidden;/* 隐藏属性 */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1 clear_fix&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"}]},{"title":"搭建博客网站","slug":"搭建博客网站","date":"2022-03-29T06:09:54.000Z","updated":"2022-04-14T03:02:59.648Z","comments":true,"path":"2022/03/29/搭建博客网站/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","excerpt":"","text":"基础配置1234567npm i -g hexohexo initnpm i hexo-serverhexo-server 主题1.获取模板 1hexo.theme.getView(path); 设置模板 1hexo.theme.setView(path, data); 3.移除模板 1hexo.theme.removeView(path); 配置完成打包上传123hexo clean //删除上次打包hexo generate //打包hexo deploy /上传","categories":[{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/tags/hexo/"}]},{"title":"字符串常用操作方法","slug":"字符串常用操作方法","date":"2022-03-29T06:05:28.000Z","updated":"2022-03-29T11:14:05.200Z","comments":true,"path":"2022/03/29/字符串常用操作方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/","excerpt":"","text":"一. length JS中的字符串有一个length属性，该属性可以用来获取字符串的长度 12const str = &quot;hello&quot;str.length //输出结果5 二.获取字符串指定位置的值 charAt() 方法获取到的是指定位置的字符 charCodeAt()方法获取的是指定位置字符的Unicode值 charAt() 12345const str = &quot;hello&quot;str.chatAt(1) // 输出结果：estr[1] // 输出结果：estr.charAt(5) // 输出结果：&quot;&quot;str[5] // 输出结果：undefine charCodeAt() 12let str = &quot;abcdefg&quot;console.log(str.charCodeAt(1)) // &quot;b&quot;--&gt; 98 三.检索字符串是否包含特定序列 indexOf() 查找某个字符，有则返回第一次匹配到的位置，否则返回-1 123456789string.indexOf(searchvalue,fromindex)searchvalue:必需，规定需检索的字符串值fromindex：可选的整数参数，规定在字符串开始检索的位置。合法取值范围是0-string.length-1.如省略，则从字符串的首字符开始检索let str = &quot;abcdefgabc&quot;console.log(str.indexOf(&quot;a&quot;)) // 输出结果：0console.log(str.indexOf(&quot;z&quot;)) // 输出结果：-1console.log(str.indexOf(&quot;c&quot;,4)) //输出结果：9 lastIndexOf() 查找某个字符，有则返回最后一次匹配的位置，否则返回-1 123let str = “abcabc”console.log(str.lastIndexOf(&quot;a&quot;)) // 输出结果：3console.log(str.lastIndexOf(&quot;z&quot;)) // 输出结果：-1 includes() 该方法用于判断字符串是否包含指定的子字符串，如果找到指定的子字符串，返回true，否则返回false 123456789string.includes(searchvalue,start)searchvalue:必需，要查找的字符串start:可选，设置从那个位置开始查找，默认为0let str = &quot;Hello world&quot;str.includes(&quot;o&quot;) // 输出结果:truestr.includes(&quot;z&quot;) // 输出结果：falsestr.includes(&quot;e&quot;,2) // 输出结果：false startsWith() 该方法用于检测字符串是否以指定的子字符串开始。如果是以指定的子字符串开头返回 true，否则 false。 123456let str = &#x27;Hello world!&#x27;;str.startsWith(&#x27;Hello&#x27;) // 输出结果：truestr.startsWith(&#x27;Helle&#x27;) // 输出结果：falsestr.startsWith(&#x27;wo&#x27;, 6) // 输出结果：true endsWith() 该方法用来判断当前字符串是否是以指定的子字符串结尾。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。 12345678910string.endsWith(searchvalue, length)searchvalue：必需，要搜索的子字符串；length： 设置字符串的长度，默认值为原始字符串长度 string.length。let str = &#x27;Hello world!&#x27;;str.endsWith(&#x27;!&#x27;) // 输出结果：truestr.endsWith(&#x27;llo&#x27;) // 输出结果：falsestr.endsWith(&#x27;llo&#x27;, 5) // 输出结果：true 四、连接多个字符串concat()123456string.concat(string1, string2, ..., stringX)let str = &quot;abc&quot;;console.log(str.concat(&quot;efg&quot;)); //输出结果：&quot;abcefg&quot;console.log(str.concat(&quot;efg&quot;,&quot;hijk&quot;)); //输出结果：&quot;abcefghijk&quot; 五、字符串分割成数组split()用于把一个字符串分割成字符串数组，该方法不会改变原始字符串 12345678string.split(separator,limit)separator:必需。字符串或正则表达式，从该参数指定的位置分割stringlimit：可选，该参数可指定返回的数组的最大长度，如果设置了该参数，返回的子字符串不会多于这个参数指定的数组；如果没有设置该参数，整个字符串都会被分割，不考虑他的长度let str = &quot;abcdef&quot;;str.split(&quot;c&quot;); // 输出结果：[&quot;ab&quot;, &quot;def&quot;]str.split(&quot;&quot;, 4) // 输出结果：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 六、截取字符串 slice() 用于提取字符串的某一部分，并以新的字符串返回提取的部分,该方法返回的子串包括开始处的字符，但不包括结束处的字符。 1234567891011string.slice(start,end)start:必需，要截取的片段的起始下标，第一个字符串位置为0，如果为负数，则从尾部开始截取end: 可选，要截取的片段结尾的下标，若未指定此参数，则要提取的字串包含start到原字符串结尾的字符串。如果是负数，则从字符串的尾部开始算起的位置let str= &quot;abcdefg&quot;str.slice(1,6) // 输出结果：“bcdef”str.slice(1) // 输出结果：“bcdefg”str.slice() // 输出结果：“abcdefg”str.slice(-2) //输出结果：“fg”str.slice(6,1) //输出结果：&quot;&quot; 2.substr()用于在字符串中抽取从开始下标开始的指定数目的字符。 123456789string.substr(start,length)start:必需，要抽取的字串的起始下标。必须是数值。如果是负数，则该参数声明从字符串的尾部开始算起的位置length：可选，子串中字符数。如果省略了该参数，则返回从stringObject的开始位置到结尾的字串let str = &quot;abcdefg&quot;str.substr(1,6) //输出结果：“bcdefg”str.substr(1) // 输出结果：“bcdefg”str.substr(-1) //输出结果：“g” 3.substring()用于提取字符串中介于两个指定下标之间的字符 123456789101112string.substring(from,to)from:必需，一个非负的整数，规定要提取的子串的第一个字符在string的位置to：可选，一个非负的整数，比要提取的子串的最后一个字符在string中的位置多1。如省略，返回的子串会一直到字符串的结尾let str = &quot;abcdefg&quot;str.substring(1,6) //输出结果：“bcdef”str.substring(1) //输出结果：“bcdefg”str.substring() // 输出结果：“abcdefg”str.substring(6,1) // 输出结果：“bcdef”str.substring(-1) // 输出结果：&quot;abcdefg&quot; 七、字符串大小写转换 toLowerCase()用于把字符串转换成小写 12let str = &quot;adABDndj&quot;str.toLowerCase(); //输出结果：“adabdndj” 2.toUpperCase()用于将字符串转换成大写 12let str = “asdfGH”str.toUpperCase(); //输出结果：“ASDFGH” 八、字符串模式匹配1.replace()用于在字符串中用一些字符串替换名一些字符串，或者替换一个与正则表达式匹配的子串 1234567891011string.replace(searchvalue,newvalue)searchvalue:必需，规定子字符串或要替换的模式的RwgExp对象。如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换成RegExp对象newvalue：必需，一个字符串的值let str = “abcdef”str.replace(&quot;c&quot;,&quot;a&quot;) // 输出结果：abadeflet str=&quot;Mr Blue has a blue house and a blue car&quot;;str.replace(/blue/gi, &quot;red&quot;); // 输出结果：&#x27;Mr red has a red house and a red car&#x27; match() 用于在字符串内检索特定的值，或找到一个或多个正则表达式的匹配 1234string.match(regexp)let str = &quot;abcdef&quot;console.log(str.match(&quot;c&quot;)) // // [&quot;c&quot;, index: 2, input: &quot;abcdef&quot;, groups: undefined] search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。只会返回第一次匹配成功的结果;如果没有找到任何匹配的子串，则返回 -1。 12345string.search(searchvalue)let str = &quot;abcdef&quot;;str.search(/bcd/) // 输出结果：1 九、移除字符串首尾空白符 trim() 用于移除字符串首尾空白符，该方法不会改变原始字符串 123let str = &quot; abcdef &quot;str.trim() // 输出结果：&quot;abcdef&quot; trimStart() trimStart() 方法的的行为与trim()一致，不过会返回一个从原始字符串的开头删除了空白的新字符串，不会修改原始字符串： 123const s = &#x27; abc &#x27;;s.trimStart() // &quot;abc &quot; trimEnd() trimEnd() 方法的的行为与trim()一致，不过会返回一个从原始字符串的结尾删除了空白的新字符串，不会修改原始字符串： 1234const s = &#x27; abc &#x27;;s.trimEnd() // &quot; abc&quot; 十、获取字符串本身 valueOf() 返回某个字符串对象的原始值，该方法通常由 JavaScript 自动进行调用，而不是显式地处于代码中。 12let str = &quot;abcdef&quot;console.log(str.valueOf()) // &quot;abcdef&quot; toString() 返回字符串对象本身 12let str = &quot;abcdef&quot;console.log(str.toString()) // &quot;abcdef&quot; 十一、重复一个字符串repeat()返回一个新字符串，表示将原字符串重复n次： 123&#x27;x&#x27;.repeat(3) // 输出结果：&quot;xxx&quot;&#x27;hello&#x27;.repeat(2) // 输出结果：&quot;hellohello&quot;&#x27;na&#x27;.repeat(0) // 输出结果：&quot;&quot; 注意：如果参数是小数，向下取整；如果参数是负数或Infinity，会报错 十二、补齐字符串长度 padStart() 用于头部补全。该方法有两个参数，其中第一个参数是一个数字，表示字符串补齐之后的长度；第二个参数是用来补全的字符串。 1234567&#x27;x&#x27;.padStart(1, &#x27;ab&#x27;) // &#x27;x&#x27;&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;) // &#x27;ababx&#x27;&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;) // &#x27;abax&#x27;&#x27;x&#x27;.padStart(4) // &#x27; x&#x27;&quot;1&quot;.padStart(3, &#x27;0&#x27;) // 输出结果： &#x27;001&#x27;&quot;15&quot;.padStart(3, &#x27;0&#x27;) // 输出结果： &#x27;015&#x27; padEnd() 用于尾部补全。该方法也是接收两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串： 123&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;) // &#x27;xabab&#x27;&#x27;x&#x27;.padEnd(4, &#x27;ab&#x27;) // &#x27;xaba&#x27; 十三、字符串转为数字1.parseInt() 用于可解析一个字符串，并返回一个整数 12345678910111213141516171819202122parseInt(string, radix)string:必需，要被解析的字符串radix：可选，表示要解析的数字的基数。parseInt(&quot;10&quot;); // 输出结果：10parseInt(&quot;17&quot;,8); // 输出结果：15 (8+7)parseInt(&quot;010&quot;); // 输出结果：10 或 8parseInt(&quot;0x10&quot;) // 输出结果：16parseInt(&quot;50&quot;, 1) // 输出结果：NaNparseInt(&quot;50&quot;, 40) // 输出结果：NaNparseInt(&quot;40 4years&quot;) // 输出结果：40parseInt(&quot;new100&quot;) // 输出结果：NaNparseInt(&quot; 60 &quot;) // 输出结果： 60 parseFloat(string) 可解析一个字符串，并返回一个浮点数。该方法指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 123456parseFloat(&quot;10.00&quot;) // 输出结果：10.00parseFloat(&quot;10.01&quot;) // 输出结果：10.01parseFloat(&quot;-10.01&quot;) // 输出结果：-10.01parseFloat(&quot;40.5 years&quot;) // 输出结果：40.5","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"数组Array的常用方法","slug":"数组Array的常用方法","date":"2022-03-29T03:36:26.000Z","updated":"2022-03-29T11:13:50.725Z","comments":true,"path":"2022/03/29/数组Array的常用方法/","link":"","permalink":"https://1518277259.github.io/2022/03/29/%E6%95%B0%E7%BB%84Array%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Array.map()将数组中的每一个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组 12345let arr = [1, 2, 3, 4, 5];let newArr = arr.map(x =&gt; x*2);// arr = [1, 2, 3, 4, 5] 原数组保持不变// newArr = [2, 4, 6, 8, 10] 返回新数组 Array.forEach()将数组中的每个元素执行传进提供的函数，没有返回值 12345let arr = [1, 2, 3, 4, 5];arr.forEach(x =&gt; x*2);console.log(arr)// arr = [1, 2, 3, 4, 5] 数组改变,注意和map区分 Array.filter()将所有元素进行判断，将满足条件的元素作为一个新的数组返回 1234let arr = [1, 2, 3, 4, 5];const isBigEnough = value =&gt; value &gt;= 3;let newArr = arr.filter(isBigEnough);// newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组 Array.eveny()将所有的元素进行判断返回一个布尔值，如果所有元素都满足条件，返回true，否则返回false 123456let arr = [1, 2, 3, 4, 5];const isLessThan4 = value =&gt; value &lt; 4;const isLessThan6 = value =&gt; value &lt; 6;arr.every(isLessThan4); // falsearr.every(isLessThan6); // true Array.some()此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false。 123456let arr= [1, 2, 3, 4, 5];const isLessThan4 = value =&gt; value &lt; 4;const isLessThan6 = value =&gt; value &gt; 6;arr.some(isLessThan4); // truearr.some(isLessThan6); // false Array.reduce()所有元素调用返回函数，返回值为最终结果，传入的值必需是函数类型 1234567let arr = [1, 2, 3, 4, 5];const add = (a, b) =&gt; a + b;let sum = arr.reduce(add);// sum = 15 相当于累加的效果// 与之相对应的还有一个 Array.reduceRight() 方法，// 区别是这个是从右向左操作的 Array.push()在数组的后面添加元素，改变了数组的长度 123456var str1 = [12,2,&quot;hello&quot;];var str2 = [43,2,&quot;test&quot;];console.log(str1.push(&quot;你好&quot;)); // 4console.log(str2.push(&quot;hello&quot;,&quot;world&quot;)); // 5console.log(str1); // [12, 2, &quot;hello&quot;,&quot;你好&quot;]console.log(str2); // [43, 2, &quot;test&quot;,&quot;hello&quot;, &quot;world&quot;] Array.pop()在数组后面删除最后一位元素，并返回数组，改变了数组的长度 12345let arr = [1, 2, 3, 4, 5];arr.pop();console.log(arr); // [1, 2, 3, 4]console.log(arr.length); // 4 Array.shift()删除数组的第一个元素，并返回数组，改变数组的长度 12345let arr = [1, 2, 3, 4, 5];arr.shift();console.log(arr); // [2, 3, 4, 5]console.log(arr.length); // 4 Array.unshift()将一个或多个元素添加到数组的开头，并返回数组的长度 1234567var str1 = [12,2,&quot;hello&quot;];var str2 = [43,2,&quot;test&quot;];console.log(str1.unshift(&quot;你好&quot;)); // 4console.log(str2.unshift(&quot;hello&quot;,&quot;world&quot;)); // 5console.log(str1); // [&quot;你好&quot;, 12, 2, &quot;hello&quot;]console.log(str2); // [&quot;hello&quot;, &quot;world&quot;, 43, 2, &quot;test&quot;] Array.isArray()判断一个对象是不是数组，返回是布尔值 123let arr = [1, 2, 3, 4, 5];console.log(arr.isArray()); // true Array.concat()可以将多个数组拼成一个数组 1234let arr1 = [1, 2, 3];arr2 = [4, 5];let arr = arr1.concat(arr2);console.log(arr); // [1, 2, 3, 4, 5] Array.toString()将数组转换成字符串，不会改变原数组 123let arr = [1, 2, 3, 4, 5];let str = arr.toString();console.log(str); // 1,2,3,4,5 Array.join()将数组转成字符串并返回字符串数据，不会改变原来的数组 1234567let arr = [1, 2, 3, 4, 5];let str1 = arr.join();let str2 = arr.join(&#x27;,&#x27;);let str3 = arr.join(&#x27;##&#x27;);console.log(str1); // 12345console.log(str2); // 1,2,3,4,5console.log(str3); // 1##2##3##4##5 Array.splice()Array.splice(开始位置，删除的个数，元素)，万能方法，可以实现增删改 1234567let arr = [1, 2, 3, 4, 5];let arr1 = arr.splice(2, 0 &#x27;haha&#x27;);let arr2 = arr.splice(2, 3);let arr1 = arr.splice(2, 1 &#x27;haha&#x27;);console.log(arr1); // [1, 2, &#x27;haha&#x27;, 3, 4, 5] 新增一个元素console.log(arr2); // [1, 2] 删除三个元素console.log(arr3); // [1, 2, &#x27;haha&#x27;, 4, 5] 替换一个元素 Array.slice()此方法截取指定位置的数组，并返回截取的数组，不会改变原数组。 12345678var arr = [&quot;T1&quot;,&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;];console.log(arr.slice(1,3)); // [&quot;J1&quot;,&quot;L1&quot;]console.log(arr.slice(1)); // [&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;]console.log(arr.slice(-4,-1)); // [&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;]console.log(arr.slice(-2)); // [&quot;L2&quot;,&quot;M1&quot;]console.log(arr.slice(1,-2)); // [&quot;J1&quot;,&quot;L1&quot;]console.log(arr); // [&quot;T1&quot;,&quot;J1&quot;,&quot;L1&quot;,&quot;L2&quot;,&quot;M1&quot;] Array.reverse()将数组的数据进行反转，并返回反转后的数组，会改变原数组 123var str1 = [12,2,&quot;hello&quot;];console.log(str1.reverse()); // [&quot;hello&quot;, 2, 12]console.log(str1); // [&quot;hello&quot;, 2, 12] Array.sort()将数组内的数据进行排序，并返回排过序的新数组，会改变原来的数组 1234567var str1 = [12,2,43,5,2,5];var str2 = [92,2,43,&quot;hello&quot;,&#x27;zoom&#x27;,5,2,5];console.log(str1.sort()); // [12, 2, 2, 43, 5, 5]console.log(str1); // [12, 2, 2, 43, 5, 5]console.log(str2.sort()); // [2, 2, 43, 5, 5, 92, &quot;abc&quot;, &quot;hello&quot;, &quot;zoom&quot;]console.log(str2); // [2, 2, 43, 5, 5, 92, &quot;abc&quot;, &quot;hello&quot;, &quot;zoom&quot;] Array.valueOf()返回数组的原始值，一般由js在后台调用，并不显示的出现在代码中 123456var str = [1,2,3];console.log(str.valueOf()); // [1,2,3]console.log(str); // [1,2,3]// 为了证明返回的是数组自身console.log(str.valueOf() == str); // true Array.IndexOf()此方法根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1，找到了指定的数据返回该数据的索引 1234567var str = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;];console.log(str.indexOf(&quot;l&quot;)); // 2console.log(str.indexOf(&quot;l&quot;,3)); // 3console.log(str.indexOf(&quot;l&quot;,4)); // -1console.log(str.indexOf(&quot;l&quot;,-1)); // -1console.log(str.indexOf(&quot;l&quot;,-3)); // 2 Array.includes()用来判断一个数组是否包含一个指定的值，如果是返回true，否则返回false 1234let site = [&#x27;runoob&#x27;, &#x27;google&#x27;, &#x27;taobao&#x27;];console.log(site.includes(&#x27;runoob&#x27;)); // true console.log(site.includes(&#x27;baidu&#x27;)); // false Array.flat()用来实现数据的扁平化 1234let site = [1, 2, [3, 4]];console.log(arr1.flat());// [1, 2, 3, 4]","categories":[{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}],"categories":[{"name":"面经","slug":"面经","permalink":"https://1518277259.github.io/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/categories/vue/"},{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/categories/JS/"},{"name":"websocket","slug":"websocket","permalink":"https://1518277259.github.io/categories/websocket/"},{"name":"webpack","slug":"webpack","permalink":"https://1518277259.github.io/categories/webpack/"},{"name":"模块","slug":"模块","permalink":"https://1518277259.github.io/categories/%E6%A8%A1%E5%9D%97/"},{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/categories/CSS/"},{"name":"http","slug":"http","permalink":"https://1518277259.github.io/categories/http/"},{"name":"git","slug":"git","permalink":"https://1518277259.github.io/categories/git/"},{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/categories/hexo/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://1518277259.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"vue","slug":"vue","permalink":"https://1518277259.github.io/tags/vue/"},{"name":"JS","slug":"JS","permalink":"https://1518277259.github.io/tags/JS/"},{"name":"websocket","slug":"websocket","permalink":"https://1518277259.github.io/tags/websocket/"},{"name":"webpack","slug":"webpack","permalink":"https://1518277259.github.io/tags/webpack/"},{"name":"模块","slug":"模块","permalink":"https://1518277259.github.io/tags/%E6%A8%A1%E5%9D%97/"},{"name":"CSS","slug":"CSS","permalink":"https://1518277259.github.io/tags/CSS/"},{"name":"html","slug":"html","permalink":"https://1518277259.github.io/tags/html/"},{"name":"http","slug":"http","permalink":"https://1518277259.github.io/tags/http/"},{"name":"git","slug":"git","permalink":"https://1518277259.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://1518277259.github.io/tags/hexo/"},{"name":"前端","slug":"前端","permalink":"https://1518277259.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}