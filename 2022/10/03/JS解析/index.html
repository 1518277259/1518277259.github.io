<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> JS解析 · ysp博客</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="JS解析"><meta name="keywords" content="JS、面经"><meta name="author" content="杨书平"><link rel="short icon" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/favicon.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://1518277259.github.io/atom.xml" title="ysp博客"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="ysp博客" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">JS解析</h1><div class="post-info">2022-10-03<p class="visit"><i data-identity="2022/10/03/JS解析/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h1 id="JS解析"><a href="#JS解析" class="headerlink" title="JS解析"></a>JS解析</h1><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>string 、number、 boolean、null、undefine、symbol、bigInt</p>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>function、array、RegExp、Date、Math</p>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>(一)普通函数的调用，this指向的是Window</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cat</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;有鱼&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">cat</span>(); <span class="comment">//卡卡</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(二)对象的方法，this指的是该对象</p>
<ol>
<li>一层作用域时，this指的是该对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;有鱼&#x27;</span>,</span><br><span class="line">  <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">cat.<span class="title function_">eat</span>();<span class="comment">//有鱼</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>多层作用域时，this指的是距离方法最近的一层对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;有鱼&#x27;</span>,</span><br><span class="line">  <span class="attr">eat1</span>:&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;年年&#x27;</span>,</span><br><span class="line">    <span class="attr">eat2</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">cat.<span class="property">eat1</span>.<span class="title function_">eat2</span>();<span class="comment">//年年</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eat3 = cat.<span class="property">eat1</span>.<span class="property">eat2</span>;</span><br><span class="line"><span class="title function_">eat3</span>(); <span class="comment">// 卡卡</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(三)构造函数的调用，this指的是实例化的新对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;有鱼&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;英短蓝猫&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1);<span class="comment">// 实例化新对象 Cat &#123;name: &quot;有鱼&quot;, type: &quot;英短蓝猫&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">name</span>);<span class="comment">// 有鱼</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（四）apply和call调用时，this指向参数中的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;有鱼&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eat</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;年年&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;高飞&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eat.<span class="title function_">call</span>(cat);<span class="comment">// 年年</span></span><br><span class="line">eat.<span class="title function_">call</span>(dog);<span class="comment">// 高飞</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（五）匿名函数调用，指向的是全局对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;有鱼&#x27;</span>,</span><br><span class="line">  <span class="attr">eat</span>:(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">cat.<span class="property">eat</span>; <span class="comment">//卡卡</span></span><br></pre></td></tr></table></figure>

<p>（六）定时器中调用，指向的是全局变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;卡卡&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;有鱼&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);<span class="comment">// 卡卡</span></span><br><span class="line">  <span class="built_in">clearInterval</span>(cat);</span><br><span class="line">&#125;,<span class="number">500</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（七）箭头函数调用</p>
<p>&amp;emsp;&amp;nbsp;如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this的值则被设置为全局对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;若川&#x27;</span>,</span><br><span class="line">    <span class="attr">doSth</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// var self = this;</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">arrowDoSth</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="comment">// console.log(self.name);</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">arrowDoSth</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">arrowDoSth2</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.<span class="title function_">doSth</span>(); <span class="comment">// &#x27;若川&#x27;</span></span><br><span class="line">student.<span class="title function_">arrowDoSth2</span>(); <span class="comment">// &#x27;window&#x27;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>注意</strong></em></p>
<blockquote>
<p>①普通函数的调用，this指向的是window <br><br>②对象方法的调用，this指的是该对象，且是最近的对象<br><br>③构造函数的调用，this指的是实例化的新对象<br><br>④apply和call调用，this指向参数中的对象<br><br>⑤匿名函数的调用，this指向的是全局对象window<br><br>⑥定时器中的调用，this指向的是全局变量window<br><br>⑦.箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this的值则被设置为全局对象<br><br>⑧.onclick和addEventerListener是指向绑定事件的元素（ev.currentTarget）<br></p>
</blockquote>
<h3 id="call、apply、bind的原理及实现"><a href="#call、apply、bind的原理及实现" class="headerlink" title="call、apply、bind的原理及实现"></a>call、apply、bind的原理及实现</h3><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>&amp;emsp;&amp;nbsp;改变当前函数this指向，并立即执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycall</span> = <span class="keyword">function</span>(<span class="params">context,...args</span>)&#123;</span><br><span class="line">    context = (context == <span class="literal">null</span> || context == undefine)?<span class="attr">window</span>:<span class="keyword">new</span> <span class="title class_">Object</span>(context)</span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">    context.<span class="property">fn</span> = (...args)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>&amp;emsp;&amp;nbsp;将函数中的this指向传入的第一个参数，第二个为数组,和call方法作用相同，参数不同，立即执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myapply</span> = <span class="keyword">function</span>(<span class="params">context,args</span>)&#123;</span><br><span class="line">    context = (context == <span class="literal">null</span>|| context == undefine)?<span class="attr">window</span>:<span class="keyword">new</span> <span class="title class_">Object</span>(context)</span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">if</span>(!args) <span class="keyword">return</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span>+args+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>&amp;emsp;&amp;nbsp;bind() 方法创建一个新的函数，不自动执行，需要手动调用bind() 。这个新函数的 this 被指定为 bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mybind</span> = <span class="keyword">function</span>(<span class="params">context,...args1</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fbind</span>(<span class="params">...args2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> that.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">instanceof</span> fbind? <span class="variable language_">this</span> :context,...args1,...args2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">        fbind.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">        <span class="keyword">return</span> fbind</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>&amp;emsp;&amp;nbsp;变量提升是指在js代码执行过程中，js引擎把变量的声明部分和函数声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值undefined<br><br>&amp;emsp;&amp;nbsp;js在编译阶段的时候，会搜集所有的变量声明并且提前声明变量，而其他的语句都不会改变他们的顺序，因此，在编译阶段的时候，第一步就已经执行了，而第二步则是在执行阶段执行到该语句的时候才执行。</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>&amp;emsp;&amp;emsp;执行上下文是js代码执行的一个环境，存放了代码执行所需的变量，变量查找的作用域链规则以及this指向等。在编译阶段创建</p>
<ol>
<li>全局执行上下文：当进入全局代码时会进行编译，在编译中创建全局执行上下文，并生成可执行代码</li>
<li>函数执行上下文：执行代码的过程中，如果遇到函数调用，会编译函数内的代码和创建函数执行上下文，并创建可执行代码</li>
<li>eval执行上下文：：当使用eval函数的时候，eval的代码也会被编译，并创建执行上下文</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol>
<li>全局作用域：不在函数内部作用域和块级内部作用域外的作用域</li>
<li>函数作用域：在函数内部的作用域 </li>
<li>块级作用域：在花括号{}内部的作用域</li>
</ol>
<p><em><strong>注意：</strong></em></p>
<p>&amp;emsp;&amp;emsp;①对象的{}不属于块级作用域，像for(){},if(){},else{}，try{},cath(){}等等的花括号才是块级作用域<br><br>&amp;emsp;&amp;emsp;②对象的{}的作用域是什么作用域取决于对象所处的作用域，比如对象在全局作域 下定义的，那么对象的{}的作用域就是全局作用域</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>&amp;emsp;&amp;emsp;内部作用域访问外部作用域的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链,采取就近原则的方式向上一级一级的作用域来查找变量值，最顶级是全局作用域，如果到全局作用域也没找值，那么就会报错。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>&amp;emsp;&amp;emsp;如果一个函数访问了此函数的父级及父级以上的作用域变量，那么这个函数就是一个闭包。即函数不在当前语法作用域中执行，而是在当前语法作用域外执行，但仍然保持对当前语法作用域的引用，这种引用叫闭包</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>被闭包函数访问的父级及以上的函数的局部变量（如范例中的局部变量 i ）会一直存在于内存中，不会被JS的垃圾回收机制回收。</li>
<li>闭包函数实现了对其他函数内部变量的访问。（函数内部的变量对外是无法访问的，闭包通过这种变通的方法，实现了访问。）</li>
</ol>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol>
<li>访问函数内部的变量</li>
<li>让变量始终保持在内存中</li>
<li>使用不当会导致内存泄漏</li>
</ol>
<h3 id="new-的原理"><a href="#new-的原理" class="headerlink" title="new 的原理"></a>new 的原理</h3><ol>
<li>创建一个空对象作为返回实例</li>
<li>将这个空对象的原型，指向构造函数的prototype属性</li>
<li>将这个空对象赋值给构造函数内部的this关键字</li>
<li>开始执行构造函数内部的代码</li>
<li>返回这个对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn,...arg</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">        <span class="keyword">let</span> result = fn.<span class="title function_">apply</span>(obj,arg)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> result  === <span class="string">&#x27;object&#x27;</span> ? result : obj;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>&amp;emsp;&amp;emsp;在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数<br></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.<span class="property">constructor</span> == <span class="title class_">Person</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Person</span></span><br><span class="line">person1.<span class="property">__proto__</span> == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>  原型对象（Person.prototype）是 构造函数（Person）的一个实例。<br><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/652991a67186">原型与原型链参考文章</a></p>
<h3 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h3><ol>
<li>捕获阶段：事件从window对象自上而下向目标节点传播的阶段；</li>
<li>目标阶段：真正的目标节点正在处理事件的阶段；</li>
<li>冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。</li>
</ol>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>&amp;emsp;&amp;emsp;模块化开发是一种管理方式，一种生产方式，一种解决问题的方案。一个模块就是实现某个特定功能的文件，我们可以很方便的使用别人的代码，想要什么模块，就引入那个模块。<br></p>
<p> &amp;emsp;&amp;emsp;防止出现命名冲突，污染作用域等一系列问题</p>
<h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><p>&amp;emsp;&amp;emsp;迭代器对象本质上，就是一个指针对象。通过指针对象的next(), 用来移动指针。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--<span class="title class_">JavaScript</span> 原有的<span class="keyword">for</span>...<span class="keyword">in</span>循环，只能获得对象的键名，不能直接获取键值。<span class="title class_">ES6</span> 提供<span class="keyword">for</span>...<span class="keyword">of</span>循环，允许遍历获得键值。--&gt;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>promise共有三种状态，pending,fulfilled,rejected</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义实现promise</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="variable language_">this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 当前状态</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span> <span class="comment">// 存储成功的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span> <span class="comment">// 存储失败的值</span></span><br><span class="line">  <span class="comment">// 利用发布订阅模式，让Promise支持异步</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onFulfilledFunc</span> = [] <span class="comment">// 存储成功的回调</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedFunc</span> = [] <span class="comment">// 存储失败的回调</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (value) &#123;</span><br><span class="line">   <span class="comment">// Promise对象已经由pending状态改变为了成功态（resolved）或是失败态（rejected）就不能再次更改状态了。因此我们在更新状态时要判断，如果当前状态是pending（等待态）才可更新</span></span><br><span class="line">   <span class="keyword">if</span> (_this.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    _this.<span class="property">value</span> = value</span><br><span class="line">    <span class="comment">//依次执行成功回调</span></span><br><span class="line">    _this.<span class="property">onFulfilledFunc</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(value))</span><br><span class="line">    _this.<span class="property">state</span> = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (reason) &#123;</span><br><span class="line">   <span class="comment">// Promise对象已经由pending状态改变为了成功态（resolved）或是失败态（rejected）就不能再次更改状态了。因此我们在更新状态时要判断，如果当前状态是pending（等待态）才可更新</span></span><br><span class="line">   <span class="keyword">if</span> (_this.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    _this.<span class="property">reason</span> = reason</span><br><span class="line">    <span class="comment">//依次执行失败回调</span></span><br><span class="line">    _this.<span class="property">onRejectedFunc</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(reason))</span><br><span class="line">    _this.<span class="property">state</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 当实例化Promise时，构造函数中就要马上调用传入的executor函数执行</span></span><br><span class="line">   <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   <span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> _resolvePromise (promise2, x, resolve, reject) &#123;</span><br><span class="line">  <span class="comment">// 如果返回了自己的Promise对象，状态永远为等待态（pending），再也无法成为resolved或是rejected，程序会死掉，因此首先要处理它</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">   <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Promise存在循环引用&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">   <span class="comment">// x可能是一个promise</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> then = x.<span class="property">then</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">     then.<span class="title function_">call</span>(x, <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">_resolvePromise</span>(promise2, y, resolve, reject)</span><br><span class="line">     &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="title function_">resolve</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//否则是个普通值</span></span><br><span class="line">   <span class="title function_">resolve</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> then (onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">let</span> promise2</span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="keyword">function</span> (<span class="params">val</span>) &#123; <span class="keyword">return</span> val &#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="keyword">function</span> (<span class="params">reason</span>) &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">   promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">     &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">   promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">     &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">   promise2 = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledFunc</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">_resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">       <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedFunc</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">_resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">       <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><h4 id="什么是Generator"><a href="#什么是Generator" class="headerlink" title="什么是Generator"></a>什么是Generator</h4><p>&amp;emsp;&amp;emsp;是ES6提供的一种异步编程解决方案，语法不同于普通函数；简单的把Generator 理解为一个状态机，封装了多个内部状态。执行Generator 函数会返回一个迭代器对象，可以通过调用迭代器next依次遍历Generator函数内部的每一个状态。</p>
<h4 id="Generator的特征"><a href="#Generator的特征" class="headerlink" title="Generator的特征"></a>Generator的特征</h4><ol>
<li>function关键字与函数名之间有个星号；</li>
<li>函数内部使用yield表达式</li>
</ol>
<h4 id="Generator的使用"><a href="#Generator的使用" class="headerlink" title="Generator的使用"></a>Generator的使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generateSequence</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = <span class="title function_">generateSequence</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> one = generator.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(one)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>&amp;emsp;&amp;emsp;声明异步函数,遇到await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，继续执行await后面的代码。</p>
<p><strong><em>优缺点</em>：</strong> </p>
<ol>
<li>相对于promise，async&#x2F;await处理 then 的调用链，代码要清晰很多，几乎和同步代码一样</li>
<li>滥用 await 可能会导致性能问题，因为 await 会阻塞代码</li>
</ol>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>&amp;emsp;&amp;emsp;事件循环，把异步任务的回调部分交给事件循环，等时机合适交还给 JS 线程执行。事件循环并不是 JavaScript 首创的，它是计算机的一种运行机制。<br><br>&amp;emsp;&amp;emsp;所有任务都可以分成同步任务和异步任务，当任务进入执行栈，会判断任务是同步还是异步任务，如果是同步任务进行主线程，异步任务进入异步队列(event Queue),等待主线程中的任务执行完毕后，会在异步队列中读取相应的任务(先进先出)，推入主线程执行，这个上述过程不断重复就是事件循环（Event Loop）</p>
<p>&amp;emsp;&amp;emsp;事件循环是由一个队列组成的，异步任务的回调遵循先进先出，在 JS 引擎空闲时会一轮一轮地被取出，所以被叫做循环。</p>
<h3 id="垃圾回收-GC"><a href="#垃圾回收-GC" class="headerlink" title="垃圾回收(GC)"></a>垃圾回收(GC)</h3><p>&amp;emsp;&amp;emsp;是清理程序不用的内存或者是之前用过了，以后不会再用的内存空间。</p>
<h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><p>&amp;emsp;&amp;emsp;垃圾回收主要也是针对堆内存中的对象，对于栈中的非闭包变量，会被栈执行上下文切换时直接出栈，释放了内存空间</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol>
<li>内存泄漏：当不再用到的对象内存，没有及时被回收，想要避免就让无用数据不存在引用关系。</li>
<li>内存膨胀：即在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用。</li>
<li>频繁GC: GC执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收。</li>
</ol>
<h4 id="泄露类型"><a href="#泄露类型" class="headerlink" title="泄露类型"></a>泄露类型</h4><ol>
<li>闭包</li>
<li>隐式全局变量</li>
<li>DOM引用</li>
<li>定时器</li>
<li>事件监听</li>
<li>事件监听发布</li>
<li>Map、Set强引用</li>
<li>未清理的console</li>
</ol>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>&amp;emsp;&amp;emsp;会在栈中开辟另一块空间，并将被拷贝对象的栈内存数据完全拷贝到该块空间中，即基本数据类型的值会被完全拷贝，而引用类型的值则是拷贝了“指向堆内存的地址”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="comment">// 引用类型需要开辟一个新的存储地址</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> copy = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">        copy[prop] = target[prop]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是基础类型就直接返回</span></span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>&amp;emsp;&amp;emsp;不仅会在栈中开辟另一块空间，若被拷贝对象中有引用类型，则还会在堆内存中开辟另一块空间存储引用类型的真实数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">  <span class="attr">func</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)&#125;,</span><br><span class="line">  <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;h&#x27;</span> , <span class="attr">data</span>: &#123; <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data&#x27;</span>) &#125;, <span class="attr">child</span>: <span class="string">&#x27;child&#x27;</span> &#125;&#125;,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  <span class="attr">und</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">ref</span>: <span class="regexp">/^123$/</span>,</span><br><span class="line">  <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">  <span class="title class_">NaN</span>: <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="attr">infinity</span>: <span class="title class_">Infinity</span>,</span><br><span class="line">  <span class="attr">sym</span>: <span class="title class_">Symbol</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 日期类型直接返回一个新的日期对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)</span><br><span class="line">  <span class="comment">// 正则对象直接返回新的正则对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)</span><br><span class="line">  <span class="comment">// 循环引用使用 weakMap 解决</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj)</span><br><span class="line">  <span class="keyword">const</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">  <span class="comment">// 获取原型上的方法和对象的描述信息，创建新的对象</span></span><br><span class="line">  <span class="keyword">const</span> copyObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj), desc)</span><br><span class="line">  hash.<span class="title function_">set</span>(obj, copyObj)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环递归遍历内容，防止还会有共计内存的问题</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = obj[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;object&#x27;</span> &amp;&amp; item !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> item !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      copyObj[key] = <span class="title function_">deepCopy</span>(item)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      copyObj[key] = item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copyObj</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">deepCopy</span>(obj3))</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝和浅拷贝的区分"><a href="#深拷贝和浅拷贝的区分" class="headerlink" title="深拷贝和浅拷贝的区分"></a>深拷贝和浅拷贝的区分</h4><p>&amp;emsp;&amp;emsp;简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短；如果B没变，那就是深拷贝，自食其力。</p>
<h3 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h3><p>&amp;emsp;&amp;emsp;在进行窗口的resize、scroll、输出框内容校验等操纵的时候，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常之差。那么为了前端性能的优化也为了用户更好的体验，就可以采用防抖（debounce）和节流（throttle）的方式来到达这种效果，减少调用的频率。</p>
<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>&amp;emsp;&amp;emsp;一定在事件触发 n 秒后才执行，如果在一个事件触发的 n 秒内又触发了这个事件，以新的事件的时间为准，n 秒后才执行，等触发事件 n 秒内不再触发事件才执行。 即计最后一次触发</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">debounced</span> () &#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="variable language_">this</span>, args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout)  <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                result = func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                result = func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.<span class="property">cancel</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">cleatTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>&amp;emsp;&amp;emsp;当持续触发事件时，保证一定时间段内只调用一次事件处理函数。即计第一次触发</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">var</span> remaining = wait-(curTime-startTime); </span><br><span class="line">        <span class="keyword">var</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(remaining&lt;=<span class="number">0</span>)&#123; </span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line"></span><br><span class="line">            startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(fun, remaining);  <span class="comment">// 如果小于wait 保证在差值时间后执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Proxy代理"><a href="#Proxy代理" class="headerlink" title="Proxy代理"></a>Proxy代理</h3><p>&amp;emsp;&amp;emsp;Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target:要使用 Proxy 包装的目标对象</span></span><br><span class="line"><span class="comment">// handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时，代理 p 的行为</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;Proxy可以帮我们对数据的处理，对构造函数的处理，对数据的验证，说白了，就是在我们访问对象前添加了一层拦截，可以过滤很多操作，而这些过滤，由你来定义。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>&amp;emsp;&amp;emsp;Ajax 异步通信技术，是Asynchronous JavaScript+XML的简写，这种技术允许向服务器请求额外的数据而无需卸载（刷新）页面。</p>
<h4 id="通信步骤"><a href="#通信步骤" class="headerlink" title="通信步骤"></a>通信步骤</h4><ol>
<li>新建XMLHttpRequest对象</li>
<li>打开要发送的地址通道</li>
<li>给XMLHttpRequest对象增加侦听器，用来侦听各种情况</li>
<li>发送数据给打开的地址</li>
</ol>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ol>
<li>join()：用指定的分隔符将数组每一项拼接为字符串</li>
<li>push()：向数组的末尾添加新元素</li>
<li>pop()：删除数组的最后一项</li>
<li>unshift()：向数组首位添加新元素</li>
<li>shift()：删除数组的第一项</li>
<li>slice()：按照条件查找出其中的部分元素</li>
<li>splice()：对数组进行增删改</li>
<li>filter()：过滤功能</li>
<li>concat()：用于连接两个或多个数组</li>
<li>indexOf()：检测当前值在数组中第一次出现的位置索引</li>
<li>lastIndexOf()：检测当前值在数组中最后一次出现的位置索引</li>
<li>every()：判断数组中每一项都是否满足条件</li>
<li>some()：判断数组中是否存在满足条件的项</li>
<li>includes()：判断一个数组是否包含一个指定的值</li>
<li>sort()：对数组的元素进行排序</li>
<li>reverse()：对数组进行倒序</li>
<li>forEach()：es5及以下循环遍历数组每一项</li>
<li>map()：es6循环遍历数组每一项</li>
<li>find()：返回匹配的项</li>
<li>findIndex()：返回匹配位置的索引</li>
<li>reduce()：从数组的第一项开始遍历到最后一项，返回一个最终的值</li>
<li>reduceRight()：从数组的最后一项开始遍历到第一项，返回一个最终的值</li>
<li>toLocaleString()、toString()：将数组转换为字符串</li>
<li>entries()、keys()、values()：遍历数组</li>
</ol>
<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><h4 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h4><ol>
<li>let：使用let声明的变量具有块级作用域:，只能在当前声明的代码块中使用，必须要先声明再使用</li>
<li>const：具有块级作用域的特点，只能在当前声明的代码块中使用，必须要先声明再使用。常量，声明时必须赋值，不能改</li>
</ol>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol>
<li>可以将箭头函数赋值给一个变量，变量名字就是函数的名字，通过变量名字调用函数。</li>
<li>如果函数体中只有一行代码，且代码的执行结果就是返回值，可以省略大括号。</li>
<li>如果形参只有一个，可以省略小括号（如果没有形参，小括号不能省略）</li>
</ol>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><h4 id="新增基本数据类型-Sybmol"><a href="#新增基本数据类型-Sybmol" class="headerlink" title="新增基本数据类型 Sybmol"></a>新增基本数据类型 Sybmol</h4><h4 id="模块化-import导入-export导出"><a href="#模块化-import导入-export导出" class="headerlink" title="模块化 import导入 export导出"></a>模块化 import导入 export导出</h4><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><h4 id="新增类class关键字"><a href="#新增类class关键字" class="headerlink" title="新增类class关键字"></a>新增类class关键字</h4></div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2023/02/16/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88/" title="模块化方案" class="prev">PREV</a><a href="/2022/09/21/CSS%E8%A7%A3%E6%9E%90/" title="CSS解析" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2022 - 2023 <a target="_blank">杨书平</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;"> </span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>